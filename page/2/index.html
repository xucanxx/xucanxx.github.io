<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>咸鱼</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="I good vegetable a">
<meta property="og:type" content="website">
<meta property="og:title" content="咸鱼">
<meta property="og:url" content="https://xucanxx.github.io/page/2/index.html">
<meta property="og:site_name" content="咸鱼">
<meta property="og:description" content="I good vegetable a">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="xucanxx">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="咸鱼" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">咸鱼</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://xucanxx.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-幂等性原则" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/12/13/%E5%B9%82%E7%AD%89%E6%80%A7%E5%8E%9F%E5%88%99/" class="article-date">
  <time datetime="2023-12-13T09:05:34.000Z" itemprop="datePublished">2023-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/12/13/%E5%B9%82%E7%AD%89%E6%80%A7%E5%8E%9F%E5%88%99/">幂等性原则</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://xucanxx.github.io/2023/12/13/%E5%B9%82%E7%AD%89%E6%80%A7%E5%8E%9F%E5%88%99/" data-id="cm8758vo3002v657khw9ec8fk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-惊群效应" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/12/06/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/" class="article-date">
  <time datetime="2023-12-06T07:07:40.000Z" itemprop="datePublished">2023-12-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/12/06/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/">惊群效应</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="惊群效应"><a href="#惊群效应" class="headerlink" title="惊群效应"></a>惊群效应</h1><h2 id="惊群问题"><a href="#惊群问题" class="headerlink" title="惊群问题"></a>惊群问题</h2><ul>
<li>惊群问题是计算机科学中，当许多进程等待一个事件，事件发生后这些进程被唤醒，但只有一个进程能获得CPU执行权，其他进程又得被阻塞，这造成了严重的系统上下文切换代价。</li>
</ul>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ol>
<li>不希望把所有进程都唤醒，就采用定点唤醒某一个进程的做法<ul>
<li>比如说C++在std::condition_variable满足条件，线程唤起时，其实际上并不会唤起所有等待的线程，而是随机唤起一个正在等待的线程。这样做的达到的结果跟唤起所有线程一起争抢锁资源的结果一样，但是可以很大程度上避免系统上下报文的切换</li>
</ul>
</li>
<li>尽量避免进程上下文切换。<ul>
<li>采用合适的任务分配策略，减少正在等待线程的数量</li>
</ul>
</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%83%8A%E7%BE%A4%E9%97%AE%E9%A2%98">https://zh.wikipedia.org/wiki/%E6%83%8A%E7%BE%A4%E9%97%AE%E9%A2%98</a></p>
<h1 id="拓展资料"><a href="#拓展资料" class="headerlink" title="拓展资料"></a>拓展资料</h1><h2 id="nginx是如何解决惊群效应的"><a href="#nginx是如何解决惊群效应的" class="headerlink" title="nginx是如何解决惊群效应的"></a>nginx是如何解决惊群效应的</h2><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000044210775">https://segmentfault.com/a/1190000044210775</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xucanxx.github.io/2023/12/06/%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94/" data-id="cm8758vo40037657k4mnnf4z4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-虚假唤醒" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/12/06/%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92/" class="article-date">
  <time datetime="2023-12-06T07:01:58.000Z" itemprop="datePublished">2023-12-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/12/06/%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92/">虚假唤醒</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h1><pre><code>https://zhuanlan.zhihu.com/p/652823880
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xucanxx.github.io/2023/12/06/%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92/" data-id="cm8758voh0062657k8r4ferfl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-构造时有无-的区别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/09/25/%E6%9E%84%E9%80%A0%E6%97%B6%E6%9C%89%E6%97%A0-%E7%9A%84%E5%8C%BA%E5%88%AB/" class="article-date">
  <time datetime="2023-09-25T02:48:50.000Z" itemprop="datePublished">2023-09-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/09/25/%E6%9E%84%E9%80%A0%E6%97%B6%E6%9C%89%E6%97%A0-%E7%9A%84%E5%8C%BA%E5%88%AB/">构造时有无()的区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="构造时有无-的区别"><a href="#构造时有无-的区别" class="headerlink" title="构造时有无()的区别"></a>构造时有无()的区别</h1><p>  当有()时，会将申请到的成员变量的空间初始化，没有时则不会</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
using namespace std;
class foo &#123;
public:
	&#x2F;&#x2F;foo() &#123; cout &lt;&lt; &quot;foo&#39;s constructor&quot; &lt;&lt; endl; &#125;
	&#x2F;&#x2F;~foo() &#123; cout &lt;&lt; &quot;foo&#39;s destructor&quot; &lt;&lt; endl; &#125;
	int a;
&#125;;
int main() &#123;
	char buf[sizeof(foo)];
	foo* a &#x3D; new (buf) foo;&#x2F;&#x2F;不会将申请到的int空间初始化
	char buf2[sizeof(foo)];
	foo* b &#x3D; new (buf2) foo();&#x2F;&#x2F;则会将申请到的int空间初始化为0。
	printf(&quot;%d %d\n&quot;, a-&gt;a, b-&gt;a);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://xucanxx.github.io/2023/09/25/%E6%9E%84%E9%80%A0%E6%97%B6%E6%9C%89%E6%97%A0-%E7%9A%84%E5%8C%BA%E5%88%AB/" data-id="cm8758vo6003p657kgd7n2jr5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-brpc-http-proto的使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/07/13/brpc-http-proto%E7%9A%84%E4%BD%BF%E7%94%A8/" class="article-date">
  <time datetime="2023-07-13T09:07:39.000Z" itemprop="datePublished">2023-07-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/c/">c++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/07/13/brpc-http-proto%E7%9A%84%E4%BD%BF%E7%94%A8/">brpc-http:proto的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="brpc-http-proto的使用"><a href="#brpc-http-proto的使用" class="headerlink" title="brpc-http:proto的使用"></a>brpc-http:proto的使用</h1><p>官方文档:<br><a target="_blank" rel="noopener" href="https://brpc.apache.org/zh/docs/client/access-grpc/">https://brpc.apache.org/zh/docs/client/access-grpc/</a><br>issues:<br><a target="_blank" rel="noopener" href="https://github.com/apache/brpc/issues/1647">https://github.com/apache/brpc/issues/1647</a></p>
<p>他实际上会先解析http的头部的 Content-Type 字段<br>当Content-Type 中的值为,application&#x2F;x-protobuf,application&#x2F;proto,application&#x2F;grpc 时,他将以protobuf来解析http的包体<br>而其他情况将会 将其以其他情况解析（默认json）<br>源码片段</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if (ct.starts_with(&quot;grpc&quot;)) &#123;
       if (ct.size() &#x3D;&#x3D; (size_t)4 || ct[4] &#x3D;&#x3D; &#39;;&#39;) &#123;
           if (is_grpc_ct) &#123;
               *is_grpc_ct &#x3D; true;
           &#125;
           &#x2F;&#x2F; assume that the default content type for grpc is proto.
           return HTTP_CONTENT_PROTO;
       &#125; else if (ct[4] &#x3D;&#x3D; &#39;+&#39;) &#123;
           ct.remove_prefix(5);
           if (is_grpc_ct) &#123;
               *is_grpc_ct &#x3D; true;
           &#125;
       &#125;
       &#x2F;&#x2F; else don&#39;t change ct. Note that &quot;grpcfoo&quot; is a valid but non-grpc
       &#x2F;&#x2F; content-type in the sense of format.
   &#125;

   HttpContentType type &#x3D; HTTP_CONTENT_OTHERS;
   if (ct.starts_with(&quot;json&quot;)) &#123;
       type &#x3D; HTTP_CONTENT_JSON;
       ct.remove_prefix(4);
   &#125; else if (ct.starts_with(&quot;proto-text&quot;)) &#123;
       type &#x3D; HTTP_CONTENT_PROTO_TEXT;
       ct.remove_prefix(10);
   &#125; else if (ct.starts_with(&quot;proto&quot;)) &#123;
       type &#x3D; HTTP_CONTENT_PROTO;
       ct.remove_prefix(5);
   &#125; else if (ct.starts_with(&quot;x-protobuf&quot;)) &#123;
       type &#x3D; HTTP_CONTENT_PROTO;
       ct.remove_prefix(10);
   &#125; else &#123;
       return HTTP_CONTENT_OTHERS;
   &#125;
   return (ct.empty() || ct.front() &#x3D;&#x3D; &#39;;&#39;) ? type : HTTP_CONTENT_OTHERS;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="http-proto代码示例"><a href="#http-proto代码示例" class="headerlink" title="http:proto代码示例"></a>http:proto代码示例</h2><p>代码示例</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool send(const std::string&amp; url,const std::string&amp; data)&#123;
    brpc::Channel channel;
    brpc::ChannelOptions options;
    options.protocol &#x3D; brpc::PROTOCOL_HTTP;&#x2F;&#x2F;设置协议为http1.*
    options.timeout_ms &#x3D; FLAGS_timeout_ms&#x2F;*milliseconds*&#x2F;;
    options.max_retry &#x3D; 3;

    if (channel.Init(url, FLAGS_load_balancer.c_str(), &amp;options) !&#x3D; 0) &#123;
        LOG(ERROR) &lt;&lt; &quot;Fail to initialize channel&quot;;
        return -1;
    &#125;

    brpc::Controller cntl;
    cntl.http_request().SetHeader(&quot;Content-Type&quot;,&quot;application&#x2F;x-protobuf&quot;);
    cntl.http_request().uri() &#x3D; url;&#x2F;&#x2F;这个操作只会读取到url后面的path
    if (!data.empty()) &#123;
        cntl.http_request().set_method(brpc::HTTP_METHOD_POST);
        cntl.request_attachment().append(data);
    &#125;
    channel.CallMethod(NULL, &amp;cntl, NULL, NULL, NULL);
    if (cntl.Failed()) &#123;
        std::cerr &lt;&lt; cntl.ErrorText() &lt;&lt; std::endl;
        return -1;
    &#125;
    &#x2F;&#x2F; If -http_verbose is on, brpc already prints the response to stderr.
    if (!brpc::FLAGS_http_verbose) &#123;
        std::cout &lt;&lt; cntl.response_attachment() &lt;&lt; std::endl;
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="h2-proto代码示例"><a href="#h2-proto代码示例" class="headerlink" title="h2:proto代码示例"></a>h2:proto代码示例</h2><p>代码示例</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool send(const std::string&amp; url,const std::string&amp; data)&#123;
    brpc::Channel channel;
    brpc::ChannelOptions options;
    options.protocol &#x3D; brpc::PROTOCOL_H2;&#x2F;&#x2F;设置协议为http2.0
    options.timeout_ms &#x3D; FLAGS_timeout_ms&#x2F;*milliseconds*&#x2F;;
    options.max_retry &#x3D; 3;

    if (channel.Init(url, FLAGS_load_balancer.c_str(), &amp;options) !&#x3D; 0) &#123;
        LOG(ERROR) &lt;&lt; &quot;Fail to initialize channel&quot;;
        return -1;
    &#125;

    brpc::Controller cntl;
    cntl.http_request().SetHeader(&quot;Content-Type&quot;,&quot;application&#x2F;x-protobuf&quot;);
    cntl.http_request().uri() &#x3D; url;&#x2F;&#x2F;这个操作只会读取到url后面的path
    if (!data.empty()) &#123;
        cntl.http_request().set_method(brpc::HTTP_METHOD_POST);
        cntl.request_attachment().append(data);
    &#125;
    channel.CallMethod(NULL, &amp;cntl, NULL, NULL, NULL);
    if (cntl.Failed()) &#123;
        std::cerr &lt;&lt; cntl.ErrorText() &lt;&lt; std::endl;
        return -1;
    &#125;
    &#x2F;&#x2F; If -http_verbose is on, brpc already prints the response to stderr.
    if (!brpc::FLAGS_http_verbose) &#123;
        std::cout &lt;&lt; cntl.response_attachment() &lt;&lt; std::endl;
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://xucanxx.github.io/2023/07/13/brpc-http-proto%E7%9A%84%E4%BD%BF%E7%94%A8/" data-id="cm8758vnu000m657k0u3v7wix" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/brpc/" rel="tag">brpc</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-code-server移动端部署" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/07/12/code-server%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%83%A8%E7%BD%B2/" class="article-date">
  <time datetime="2023-07-11T17:43:16.000Z" itemprop="datePublished">2023-07-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux/">linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/07/12/code-server%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%83%A8%E7%BD%B2/">code-server移动端部署</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="code-server-安卓手机termux环境搭建"><a href="#code-server-安卓手机termux环境搭建" class="headerlink" title="code-server 安卓手机termux环境搭建"></a>code-server 安卓手机termux环境搭建</h1><p>在这里是使用的termux这个app。如果手机没有root会有一些限制，比如说无法挂载磁盘，无法访问手机文件。<br>但是跑一些服务是完全没有问题的。 </p>
<p>先把termux下载好</p>
<h2 id="安装ssh"><a href="#安装ssh" class="headerlink" title="安装ssh"></a>安装ssh</h2><p>查看ip</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 安装ssh相关依赖 </span>
pkg <span class="token function">install</span> openssl
pkg <span class="token function">install</span> openssh

<span class="token comment"># 创建ssh密钥</span>
ssh-keygen <span class="token parameter variable">-A</span>
ssh-keygen

<span class="token comment"># 设置密码</span>
<span class="token function">passwd</span>

<span class="token comment"># 查看用户名和ip</span>
<span class="token function">whoami</span>
<span class="token function">ifconfig</span>
<span class="token comment"># 开启ssh服务</span>
sshd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="code-server安装"><a href="#code-server安装" class="headerlink" title="code-server安装"></a>code-server安装</h2><p>官方文档<br><a target="_blank" rel="noopener" href="https://coder.com/docs/code-server/latest/termux">https://coder.com/docs/code-server/latest/termux</a></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 先在电脑上用 ssh连接上手机 （在电脑端链接手机敲太难受了）</span>
<span class="token function">ssh</span> username@ip <span class="token parameter variable">-p</span> <span class="token number">8022</span>

<span class="token comment"># 安装相关依赖</span>
pkg <span class="token function">install</span> <span class="token parameter variable">-y</span> tur-repo python python3
pkg <span class="token function">install</span> <span class="token parameter variable">-y</span> code-server
termux-change-repo
pkg update <span class="token parameter variable">-y</span>
pkg upgrade <span class="token parameter variable">-y</span>
pkg <span class="token function">install</span> <span class="token parameter variable">-y</span> <span class="token punctuation">\</span>
  build-essential <span class="token punctuation">\</span>
  binutils <span class="token punctuation">\</span>
  pkg-config <span class="token punctuation">\</span>
  python3 <span class="token punctuation">\</span>
  nodejs-lts
<span class="token function">npm</span> config <span class="token builtin class-name">set</span> python python3
<span class="token function">node</span> <span class="token parameter variable">-v</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>在 ～&#x2F;.conf&#x2F;code-server&#x2F;config.yaml 可以进行相关的配置</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># code启动！</span>
code-server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://xucanxx.github.io/2023/07/12/code-server%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%83%A8%E7%BD%B2/" data-id="cm8758vnw0010657kcbmyg67j" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%9E%8E%E7%8E%A9/" rel="tag">瞎玩</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-nginx入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/07/06/nginx%E5%85%A5%E9%97%A8/" class="article-date">
  <time datetime="2023-07-06T09:06:41.000Z" itemprop="datePublished">2023-07-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/07/06/nginx%E5%85%A5%E9%97%A8/">nginx入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="ngnix"><a href="#ngnix" class="headerlink" title="ngnix"></a>ngnix</h1><p>引用自大佬的博客：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hanease/p/15890509.html">https://www.cnblogs.com/hanease/p/15890509.html</a></p>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><pre class="line-numbers language-none"><code class="language-none">nginx -t             检查配置文件是否有语法错误
nginx -s reload       热加载，重新加载配置文件
nginx -s stop         快速关闭
nginx -s quit         等待工作进程处理完成后关闭<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h2><pre class="line-numbers language-none"><code class="language-none"># 工作进程的数量
worker_processes  1;
events &#123;
    worker_connections  1024; # 每个工作进程连接数
&#125;

http &#123;
    include       mime.types;
    default_type  application&#x2F;octet-stream;

    # 日志格式
    log_format  access  &#39;$remote_addr - $remote_user [$time_local] $host &quot;$request&quot; &#39;
                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;
                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot; &quot;$clientip&quot;&#39;;
    access_log  &#x2F;srv&#x2F;log&#x2F;nginx&#x2F;access.log  access; # 日志输出目录
    gzip  on;
    sendfile  on;

    # 链接超时时间，自动断开
    keepalive_timeout  60;

    # 虚拟主机
    server &#123;
        listen       8080;
        server_name  localhost; # 浏览器访问域名

        charset utf-8;
        access_log  logs&#x2F;localhost.access.log  access;

        # 路由
        location &#x2F; &#123;
            root   www; # 访问根目录
            index  index.html index.htm; # 入口文件
        &#125;
    &#125;

    # 引入其他的配置文件
    include servers&#x2F;*;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Nginx配置参数中文详细说明"><a href="#Nginx配置参数中文详细说明" class="headerlink" title="Nginx配置参数中文详细说明"></a>Nginx配置参数中文详细说明</h2><pre class="line-numbers language-none"><code class="language-none">#定义Nginx运行的用户和用户组
user www www;

#nginx进程数,建议设置为等于CPU总核心数.
worker_processes 8;

#全局错误日志定义类型,[ debug | info | notice | warn | error | crit ]
error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log info;

#进程文件
pid &#x2F;var&#x2F;run&#x2F;nginx.pid;

#一个nginx进程打开的最多文件描述符数目,理论值应该是最多打开文件数（系统的值ulimit -n）与nginx进程数相除,但
#是nginx分配请求并不均匀,所以建议与ulimit -n的值保持一致.
worker_rlimit_nofile 65535;

#工作模式与连接数上限
events
&#123;
  #参考事件模型,use [ kqueue | rtsig | epoll | &#x2F;dev&#x2F;poll | select | poll ]; epoll模型是Linux 2.6以上版本内核中的高性能网络I&#x2F;O模型,如果跑在FreeBSD上面,就用kqueue模型.
  use epoll;

  #单个进程最大连接数（最大连接数&#x3D;连接数*进程数）
  worker_connections 65535;
&#125;

#设定http服务器
http
&#123;
  include mime.types; #文件扩展名与文件类型映射表
  default_type application&#x2F;octet-stream; #默认文件类型
  #charset utf-8; #默认编码
  server_names_hash_bucket_size 128; #服务器名字的hash表大小
  client_header_buffer_size 32k; #上传文件大小限制
  large_client_header_buffers 4 64k; #设定请求缓
  client_max_body_size 8m; #设定请求缓

  # 开启目录列表访问,合适下载服务器,默认关闭.
  autoindex on; # 显示目录
  autoindex_exact_size on; # 显示文件大小 默认为on,显示出文件的确切大小,单位是bytes 改为off后,显示出文件的大概大小,单位是kB或者MB或者GB
  autoindex_localtime on; # 显示文件时间 默认为off,显示的文件时间为GMT时间 改为on后,显示的文件时间为文件的服务器时间

  sendfile on; # 开启高效文件传输模式,sendfile指令指定nginx是否调用sendfile函数来输出文件,对于普通应用设为 on,如果用来进行下载等应用磁盘IO重负载应用,可设置为off,以平衡磁盘与网络I&#x2F;O处理速度,降低系统的负载.注意：如果图片显示不正常把这个改成off.
  tcp_nopush on; # 防止网络阻塞
  tcp_nodelay on; # 防止网络阻塞

  keepalive_timeout 120; # (单位s)设置客户端连接保持活动的超时时间,在超过这个时间后服务器会关闭该链接

  # FastCGI相关参数是为了改善网站的性能：减少资源占用,提高访问速度.下面参数看字面意思都能理解.
  fastcgi_connect_timeout 300;
  fastcgi_send_timeout 300;
  fastcgi_read_timeout 300;
  fastcgi_buffer_size 64k;
  fastcgi_buffers 4 64k;
  fastcgi_busy_buffers_size 128k;
  fastcgi_temp_file_write_size 128k;

  # gzip模块设置
  gzip on; #开启gzip压缩输出
  gzip_min_length 1k; #允许压缩的页面的最小字节数,页面字节数从header偷得content-length中获取.默认是0,不管页面多大都进行压缩.建议设置成大于1k的字节数,小于1k可能会越压越大
  gzip_buffers 4 16k; #表示申请4个单位为16k的内存作为压缩结果流缓存,默认值是申请与原始数据大小相同的内存空间来存储gzip压缩结果
  gzip_http_version 1.1; #压缩版本（默认1.1,目前大部分浏览器已经支持gzip解压.前端如果是squid2.5请使用1.0）
  gzip_comp_level 2; #压缩等级.1压缩比最小,处理速度快.9压缩比最大,比较消耗cpu资源,处理速度最慢,但是因为压缩比最大,所以包最小,传输速度快
  gzip_types text&#x2F;plain application&#x2F;x-javascript text&#x2F;css application&#x2F;xml;
  #压缩类型,默认就已经包含text&#x2F;html,所以下面就不用再写了,写上去也不会有问题,但是会有一个warn.
  gzip_vary on;#选项可以让前端的缓存服务器缓存经过gzip压缩的页面.例如:用squid缓存经过nginx压缩的数据

  #开启限制IP连接数的时候需要使用
  #limit_zone crawler $binary_remote_addr 10m;

  #upstream的负载均衡,四种调度算法(下例主讲)#

  #虚拟主机的配置
  server
  &#123;
    # 监听端口
    listen 80;
    # 域名可以有多个,用空格隔开
    server_name ably.com;
    # HTTP 自动跳转 HTTPS
    rewrite ^(.*) https:&#x2F;&#x2F;$server_name$1 permanent;
  &#125;

  server
  &#123;
    # 监听端口 HTTPS
    listen 443 ssl;
    server_name ably.com;

    # 配置域名证书
    ssl_certificate C:\WebServer\Certs\certificate.crt;
    ssl_certificate_key C:\WebServer\Certs\private.key;
    ssl_session_cache shared:SSL:1m;
    ssl_session_timeout 5m;
    ssl_protocols SSLv2 SSLv3 TLSv1;
    ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;
    ssl_prefer_server_ciphers on;

    index index.html index.htm index.php;
    root &#x2F;data&#x2F;www&#x2F;;
    location ~ .*\.(php|php5)?$
    &#123;
    fastcgi_pass 127.0.0.1:9000;
    fastcgi_index index.php;
    include fastcgi.conf;
    &#125;

    # 配置地址拦截转发，解决跨域验证问题
    location &#x2F;oauth&#x2F;&#123;
    proxy_pass https:&#x2F;&#x2F;localhost:13580&#x2F;oauth&#x2F;;
    proxy_set_header HOST $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    &#125;

    # 图片缓存时间设置
    location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$ &#123;
    expires 10d;
    &#125;

    # JS和CSS缓存时间设置
    location ~ .*\.(js|css)?$ &#123;
    expires 1h;
    &#125;

    # 日志格式设定
    log_format access &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;
    &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;
    &#39;&quot;$http_user_agent&quot; $http_x_forwarded_for&#39;;
    # 定义本虚拟主机的访问日志
    access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log access;

    # 设定查看Nginx状态的地址.StubStatus模块能够获取Nginx自上次启动以来的工作状态，此模块非核心模块，需要在Nginx编译安装时手工指定才能使用
    location &#x2F;NginxStatus &#123;
      stub_status on;
      access_log on;
      auth_basic &quot;NginxStatus&quot;;
      auth_basic_user_file conf&#x2F;htpasswd;
      #htpasswd文件的内容可以用apache提供的htpasswd工具来产生.
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="Nginx多台服务器实现负载均衡："><a href="#Nginx多台服务器实现负载均衡：" class="headerlink" title="Nginx多台服务器实现负载均衡："></a>Nginx多台服务器实现负载均衡：</h2><h2 id="1-Nginx负载均衡服务器："><a href="#1-Nginx负载均衡服务器：" class="headerlink" title="1.Nginx负载均衡服务器："></a>1.Nginx负载均衡服务器：</h2><p>IP：192.168.0.4（Nginx-Server）</p>
<h2 id="2-Web服务器列表："><a href="#2-Web服务器列表：" class="headerlink" title="2.Web服务器列表："></a>2.Web服务器列表：</h2><p>Web1:192.168.0.5（Nginx-Node1&#x2F;Nginx-Web1） ；Web2:192.168.0.7（Nginx-Node2&#x2F;Nginx-Web2）</p>
<h2 id="3-实现目的：用户访问Nginx-Server（“http-mongo-demo-com-8888”）时，通过Nginx负载均衡到Web1和Web2服务器"><a href="#3-实现目的：用户访问Nginx-Server（“http-mongo-demo-com-8888”）时，通过Nginx负载均衡到Web1和Web2服务器" class="headerlink" title="3.实现目的：用户访问Nginx-Server（“http://mongo.demo.com:8888”）时，通过Nginx负载均衡到Web1和Web2服务器"></a>3.实现目的：用户访问Nginx-Server（“<a href="http://mongo.demo.com:8888”）时，通过Nginx负载均衡到Web1和Web2服务器">http://mongo.demo.com:8888”）时，通过Nginx负载均衡到Web1和Web2服务器</a></h2><p>Nginx负载均衡服务器的nginx.conf配置注释如下：</p>
<pre class="line-numbers language-none"><code class="language-none">events
&#123;
  use epoll;
  worker_connections 65535;
&#125;
http
&#123;
  #upstream的负载均衡,四种调度算法#
  #调度算法1:轮询.每个请求按时间顺序逐一分配到不同的后端服务器,如果后端某台服务器宕机,故障系统被自动剔除,
  #使用户访问不受影响
  upstream webhost &#123;
  server 192.168.0.5:6666 ;
  server 192.168.0.7:6666 ;
&#125;
#调度算法2:weight(权重).可以根据机器配置定义权重.权重越高被分配到的几率越大
upstream webhost &#123;
  server 192.168.0.5:6666 weight&#x3D;2;
  server 192.168.0.7:6666 weight&#x3D;3;
&#125;
#调度算法3:ip_hash. 每个请求按访问IP的hash结果分配,这样来自同一个IP的访客固定访问一个后端服务器,有效解决了
#动态网页存在的session共享问题
upstream webhost &#123;
  ip_hash;
    server 192.168.0.5:6666 ;
    server 192.168.0.7:6666 ;
  &#125;
  #调度算法4:url_hash(需安装第三方插件).此方法按访问url的hash结果来分配请求,使每个url定向到同一个后端服务器,
  #可以进一步提高后端缓存服务器的效率.Nginx本身是不支持url_hash的,如果需要使用这种调度算法,必须安装Nginx 的
  #hash软件包
  upstream webhost &#123;
    server 192.168.0.5:6666 ;
    server 192.168.0.7:6666 ;
    hash $request_uri;
  &#125;
  #调度算法5:fair(需安装第三方插件).这是比上面两个更加智能的负载均衡算法.此种算法可以依据页面大小和加载时间长
  #短智能地进行负载均衡,也就是根据后端服务器的响应时间来分配请求,响应时间短的优先分配.Nginx本身是不支持fair的,
  #如果需要使用这种调度算法,必须下载Nginx的upstream_fair模块

  #虚拟主机的配置(采用调度算法3:ip_hash)
  server
  &#123;
    listen 80;
    server_name mongo.demo.com;
    #对 &quot;&#x2F;&quot; 启用反向代理
    location &#x2F; &#123;
      proxy_pass http:&#x2F;&#x2F;webhost;
      proxy_redirect off;
      proxy_set_header X-Real-IP $remote_addr;
      #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      #以下是一些反向代理的配置,可选.
      proxy_set_header Host $host;
      client_max_body_size 10m; #允许客户端请求的最大单文件字节数
      client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数,
      proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时)
      proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时)
      proxy_read_timeout 90; #连接成功后,后端服务器响应时间(代理接收超时)
      proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小
      proxy_buffers 4 32k; #proxy_buffers缓冲区,网页平均在32k以下的设置
      proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2）
      proxy_temp_file_write_size 64k;
      #设定缓存文件夹大小,大于这个值,将从upstream服务器传
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="负载均衡操作演示如下："><a href="#负载均衡操作演示如下：" class="headerlink" title="负载均衡操作演示如下："></a>负载均衡操作演示如下：</h2><p>操作对象：192.168.0.4（Nginx-Server）</p>
<h2 id="创建文件夹准备存放配置文件"><a href="#创建文件夹准备存放配置文件" class="headerlink" title="创建文件夹准备存放配置文件"></a>创建文件夹准备存放配置文件</h2><p> mkdir -p &#x2F;opt&#x2F;confs<br> vim &#x2F;opt&#x2F;confs&#x2F;nginx.conf</p>
<h2 id="编辑内容如下："><a href="#编辑内容如下：" class="headerlink" title="编辑内容如下："></a>编辑内容如下：</h2><pre class="line-numbers language-none"><code class="language-none">events
&#123;
  use epoll;
  worker_connections 65535;
&#125;

http
&#123;
  upstream webhost &#123;
    ip_hash;
    server 192.168.0.5:6666 ;
    server 192.168.0.7:6666 ;
  &#125;

  server
  &#123;
    listen 80;
    server_name mongo.demo.com;
    location &#x2F; &#123;
      proxy_pass http:&#x2F;&#x2F;webhost;
      proxy_redirect off;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header Host $host;
      client_max_body_size 10m;
      client_body_buffer_size 128k;
      proxy_connect_timeout 90;
      proxy_send_timeout 90;
      proxy_read_timeout 90;
      proxy_buffer_size 4k;
      proxy_buffers 4 32k;
      proxy_busy_buffers_size 64k;
      proxy_temp_file_write_size 64k;
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://xucanxx.github.io/2023/07/06/nginx%E5%85%A5%E9%97%A8/" data-id="cm8758vny001h657kfoxjegrf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-openresty入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/07/04/openresty%E5%85%A5%E9%97%A8/" class="article-date">
  <time datetime="2023-07-04T03:44:09.000Z" itemprop="datePublished">2023-07-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/openresty/">openresty</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/07/04/openresty%E5%85%A5%E9%97%A8/">openresty入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="openresty入门"><a href="#openresty入门" class="headerlink" title="openresty入门"></a>openresty入门</h1><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>  pcre-devel openssl-devel gcc curl</p>
<h3 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h3><p>  官网:<br>  <a target="_blank" rel="noopener" href="https://openresty.org/en/download.html">https://openresty.org/en/download.html</a></p>
<p>  下载最新版</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://openresty.org/download/openresty-1.19.9.1.tar.gz
<span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> openresty-1.19.9.1.tar.gz
<span class="token builtin class-name">cd</span> openresty-1.19.9.1/
./configure
<span class="token function">sudo</span> <span class="token function">make</span> <span class="token parameter variable">-j6</span>
<span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>要是报  </p>
<pre class="line-numbers language-none"><code class="language-none">gmake[1]: cc: Command not found<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>则是没有cc指令(其实就是gcc)<br>可以先看看gcc的位置,再创建软链接</p>
<pre class="line-numbers language-none"><code class="language-none">gccPath&#x3D;$(which gcc)
ln -sf $gccPath &#x2F;bin&#x2F;cc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>再添加环境变量，以及赋权</p>
<pre class="line-numbers language-none"><code class="language-none">echo &#39;export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;openresty&#x2F;bin&#39; &gt;&gt; ~&#x2F;.bashrc
sudo chmod +s &#x2F;usr&#x2F;local&#x2F;openresty&#x2F;bin&#x2F;openresty
source ~&#x2F;.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="开始运行"><a href="#开始运行" class="headerlink" title="开始运行"></a>开始运行</h3><pre class="line-numbers language-none"><code class="language-none">openresty<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="nginx-与-lua"><a href="#nginx-与-lua" class="headerlink" title="nginx 与 lua"></a>nginx 与 lua</h2><p>参考 <a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1037840">https://cloud.tencent.com/developer/article/1037840</a><br><a target="_blank" rel="noopener" href="https://blog.openresty.com.cn/cn/or-lua-module/">https://blog.openresty.com.cn/cn/or-lua-module/</a></p>
<h3 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h3><p>假设Nginx相关的配置如下所示</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">lua_code_cache</span> <span class="token boolean">off</span></span><span class="token punctuation">;</span>
<span class="token directive"><span class="token keyword">location</span> ~ ^/api/([-_a-zA-Z0-9/]+)</span> <span class="token punctuation">&#123;</span>
    <span class="token directive"><span class="token keyword">content_by_lua_file</span> lua/<span class="token variable">$1</span>.lua</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>当来到的请求符合   ^&#x2F;api&#x2F;([-_a-zA-Z0-9&#x2F;]+)  时，会在NGX_HTTP_CONTENT_PHASE HTTP请求内容阶段交给 lua&#x2F;$1.lua来处理  </p>
<p>比如<br>&#x2F;api&#x2F;addition           交给 lua&#x2F;addition.lua 处理<br>&#x2F;api&#x2F;substraction       交给 lua&#x2F;substraction.lua 处理  </p>
<h3 id="请求的处理"><a href="#请求的处理" class="headerlink" title="请求的处理"></a>请求的处理</h3><p>content_by_lua_file对应的请求来临时，执行流程为<br>ngx_http_lua_content_handler -&gt; ngx_http_lua_content_handler_file-&gt; ngx_http_lua_content_by_chunk  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xucanxx.github.io/2023/07/04/openresty%E5%85%A5%E9%97%A8/" data-id="cm8758vny001k657k7sl3ambb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-果子私房笔记-进程和线程的通信" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/03/28/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/" class="article-date">
  <time datetime="2023-03-28T01:12:00.000Z" itemprop="datePublished">2023-03-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/03/28/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/">果子私房笔记-进程和线程的通信</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="进程和线程的通信"><a href="#进程和线程的通信" class="headerlink" title="进程和线程的通信"></a>进程和线程的通信</h1><p>进程间通讯方式有:管道,信号,信号量,消息队列,共享内存,套接字(socket)共六种</p>
<h2 id="1-管道"><a href="#1-管道" class="headerlink" title="1.管道"></a>1.管道</h2><p>本质：管道的本质其实就是内核中的一块缓冲区，多个进程通过访问同一个缓冲区就可以实现进程间的通信。<br>分类：匿名管道，命名管道</p>
<h3 id="1-1匿名管道"><a href="#1-1匿名管道" class="headerlink" title="1.1匿名管道"></a>1.1匿名管道</h3><p>没有具体的文件描述符，只能适用于具有亲缘关系的进程间通信，父进程在创建管道的时候操作系统会返回管道的文件描述符，然后生成子进程时，子进程会通过拷贝父进程的pcb来获取到这个管道的描述符。<br>读写特性：1. 没数据 read 阻塞。2. 满数据，write 阻塞。3. 所有读端pipefd[0]关闭，调用 write 导致异常退出进程。4. 所有写端pipefd[1]关闭，调用 read 读完数据，返回0。</p>
<h3 id="1-2命名管道"><a href="#1-2命名管道" class="headerlink" title="1.2命名管道"></a>1.2命名管道</h3><p>命名管道也是内核中的一块缓冲区，但是它具有标识符，这个标识符是一个可见于文件系统的管道文件，能够被其他进程找到并打开管道文件来获取管道的操作句柄。<br>open打开命名管道的特性：1. 若文件以只读打开，则会阻塞，直到文件被以写的方式打开。2. 若文件以只写打开，则会阻塞，直到文件被以读的方式打开。</p>
<h4 id="管道的特性："><a href="#管道的特性：" class="headerlink" title="管道的特性："></a>管道的特性：</h4><p>(1).半双工通信（数据只能在一个方向上流动）<br>(2).管道自带同步和互斥<br>(3).读写特性，无数据则读阻塞，满数据写阻塞，所有读关闭则写端异常，所有写端关闭则读端读完数据后不堵塞返回0。<br>(4).管道声明周期随进程<br>(5).管道提供字节流传输服务<br>(6).命名管道额外有一个打开特性</p>
<h2 id="2-共享内存"><a href="#2-共享内存" class="headerlink" title="2.共享内存"></a>2.共享内存</h2><p>定义：开辟物理内存上的空间，然后在进程的页表上，将同一个物理内存映射到自己的虚拟地址空间，各进程通过自己的虚拟空间来共享访问这一块空间。<br>特点：<br>(1).共享内存是最快的进程间通信方式，因为进程是直接对内存进行存取。<br>(2).因为多个进程可以同时操作，所以需要使用信号量进行同步。<br>接口：<br>创建 int shmget(key_t key, size_t size, int shmflg)<br>映射 void *shmat(int shmid, const void *shmaddr, int shmflg)<br>共享内存管理 int shmctl(int shmid, int cmd, struct shmid_ds *buf)<br>解除映射关系 int shmdt(const void *shmaddr)<br>问题：<br>(1).超过共享内存的大小限制怎么办？修改参数<br>(2).同一个进程多次进行shmat会出现什么问题？<br>指向这块共享内存的引用计数会增加，比较消耗虚拟内存空间8</p>
<h2 id="3-消息队列："><a href="#3-消息队列：" class="headerlink" title="3.消息队列："></a>3.消息队列：</h2><p>定义：是消息的链表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。<br>特点：<br>(1).消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。<br>(2).消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。<br>(3).消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</p>
<h2 id="4-信号"><a href="#4-信号" class="headerlink" title="4.信号"></a>4.信号</h2><p>定义：信号是在软件层次上对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的，用于通知接收进程某个事件已经发生。如果接收进程并未处于执行状态，则该信号就由内核保存起来，知道该进程恢复执行并传递给他为止。如果一个信号可以被进程设置为阻塞，如果如此，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。<br>响应：<br>(1).忽略信号，即对信号不做任何处理 (有 2 个例外：sigkill,sigstop)<br>(2).捕捉信号，定义信号处理函数，当信号发生时，执行相应的处理函数<br>(3).默认操作，Linux对每种信号都规定了默认操作</p>
<h2 id="5-信号量"><a href="#5-信号量" class="headerlink" title="5.信号量"></a>5.信号量</h2><p>定义：它是一个临界变量。用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。<br>特点：<br>(1).信号量用于进程间同步，若要在进程间传递数据通常结合共享内存。<br>(2).信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。<br>(3).每次对信号量的 PV 操作不仅限于对信号量值加1或减1，而且可以加减任意正整数。<br>(4).支持信号量组。</p>
<h2 id="6-套接字-socket"><a href="#6-套接字-socket" class="headerlink" title="6.套接字( socket )"></a>6.套接字( socket )</h2><p>介绍：套解字也是一种进程间通信机制（传输层实现端到端的通信），与其他通信机制不同的是，它可用于不同机器间的进程通信。它可以看成是两个网络应用程序进行通信时，各自通信连接中的一个端点。通信时，其中的一个网络应用程序将要传输的一段信息写入它所在主机的Socket中，该Socket通过网络接口卡的传输介质将这段信息发送给另一台主机的Socket中，使这段信息能传送到其他程序中。因此，两个应用程序之间的数据传输要通过套接字来完成。<br>socket()函数：socket是一种”打开—读&#x2F;写—关闭”模式的实现，服务器和客户端各自维护一个”文件”，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。<br>bind()函数：bind()函数把一个地址族中的特定地址赋给socket。（该函数只有服务器端才需要调用）<br>listen()函数：如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。（该函数只有服务器端才需要调用）<br>accept()函数：当客户端通过调用connect()函数发送链接请求后。一旦服务器监听到该请求之后，就会调用accept()函数接收请求，这样连接就建立好了，之后就可以开始网络I&#x2F;O操作了，类同于普通文件的读写I&#x2F;O操作。（该函数只有服务器端才需要调用）<br>connect()函数：客户端如果想发送链接请求，首先需要调用socket()函数，来创建socket描述符，然后就可以调用connect()函数来向服务器端发送请求。 （该函数只有客户端端才需要调用）<br>read()、write()等函数：既然一个套接字端点被表示为一个文件描述符，因此只要建立链接，就可以使用为本地文件设计的read和write函数。<br>close()函数： 在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。</p>
<h2 id="注"><a href="#注" class="headerlink" title="注:"></a>注:</h2><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>1.无名管道：速度慢，容量有限，只有父子进程能通讯。（需要四次拷贝才能交流数据）<br>2.有名管道：任何进程间都能通讯，但速度慢。<br>3.消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题<br>4.信号量：不能传递复杂消息，只能用来同步<br>5.共享内存区：能够很容易控制容量，速度快（只需要两次拷贝），但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>1.是通过共享变量，线程之间通过该变量进行协作通信；<br>2.通过队列（本质上也是线程间共享同一块内存）来实现消费者和生产者的模式来进行通信；</p>
<p>线程同步：保证线程之间协调工作，能互相配合。比如后面的线程需要用到前面线程产生的数据。（一定程度上和线程互斥有相似）（举例生产者消费者问题）<br>线程异步：异步可以按规定顺序去执行线程，多用于 比如一个网页信息 ，（你把他分成2个线程或者多个，先读取它的title，时间，作者等等 第二个或者其他进程用于读取数据量较大的正文内容，比如图片）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xucanxx.github.io/2023/03/28/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/" data-id="cm8758voi0065657kgj9l75tw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0/" rel="tag">果子私房笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-果子私房笔记-进程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/10/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-%E8%BF%9B%E7%A8%8B/" class="article-date">
  <time datetime="2023-02-09T23:02:37.000Z" itemprop="datePublished">2023-02-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/10/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-%E8%BF%9B%E7%A8%8B/">果子私房笔记-进程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="1-什么是进程？"><a href="#1-什么是进程？" class="headerlink" title="1.什么是进程？"></a>1.什么是进程？</h2><p>程序：程序是指令和数据的集合<br>进程：进程就是程序的一次执行过程，是系统进行资源分配和调度的基本单位</p>
<h2 id="2-如何操作进程？"><a href="#2-如何操作进程？" class="headerlink" title="2.如何操作进程？"></a>2.如何操作进程？</h2><p>设立了PCB (进程控制块），其内容如下。<br>标示符：描述本进程的唯一标示符，用来区别其他进程。<br>状态：任务状态，退出代码，退出信号等。<br>优先级：相对于其他进程的优先级。<br>程序计数器：程序中即将被执行的下一条指令的地址。<br>内存指针：包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针<br>上下文数据：进程执行时处理器的寄存器中的数据。<br>I／O状态信息：包括显示的I&#x2F;O请求,分配给进程的I／O设备和被进程使用的文件列表。<br>记账信息：可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。 其他信息<br>CPU对进程的调度使用<br>CPU通过PCB中的内存指针来找到程序在内存中的地址，通过上下文数据来记录运行中程序的各种信息，通过程序计数器来找到这个程序即将执行的下一条指令的地址。</p>
<h2 id="3-进程的状态"><a href="#3-进程的状态" class="headerlink" title="3.进程的状态"></a>3.进程的状态</h2><p>三种基本状态：就绪、运行、阻塞<br>五种状态：新建状态，就绪状态，运行状态，阻塞状态，退出状态。</p>
<h2 id="4-子进程"><a href="#4-子进程" class="headerlink" title="4.子进程"></a>4.子进程</h2><p>当我们在一个已经创建的进程内通过fork创建一个新的进程时，这个新的进程就是原先进程的子进程。<br>在子进程创建的时候，它从父进程的PCB中复制了很多数据，如内存指针、上下文数据、程序计数器等，所以它的代码、数据以及运行的位置，都与父进程一模一样。<br>由于代码段是只读的，所以两者的代码都一样，不可修改，而两者虽然虚拟地址相同，但物理地址不同，所以两者的数据都各自独立。<br>一般来说，子进程先结束执行，然后父进程负责子进程的一些善后工作（回收资源）。<br>总结一下就是：父子进程代码共享，数据各自开辟空间。(利用写时拷贝技术)<br>我们创建子进程，希望它和父进程执行不一样的操作，该怎么实现呢？<br>最简单的方法就是通过fork的返回值来进行代码分流，父进程的返回值是子进程的pid，而子进程的返回值是0，通过对返回值的判断，即可完成代码的分流。</p>
<h2 id="5-进程的概念"><a href="#5-进程的概念" class="headerlink" title="5.进程的概念"></a>5.进程的概念</h2><h3 id="僵尸进程："><a href="#僵尸进程：" class="headerlink" title="僵尸进程："></a>僵尸进程：</h3><p>一个进程的子进程退出执行后，父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵死进程。<br>子进程的进程号就会一直被占用，但是系统所能使用的进程号有限，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。<br>解决方法有两种分别是退出父进程和进程等待。</p>
<h3 id="孤儿进程："><a href="#孤儿进程：" class="headerlink" title="孤儿进程："></a>孤儿进程：</h3><p>父进程运行结束，但子进程还在运行(未运行结束)的子进程就称为孤儿进程。孤儿进程最终会被init进程(进程号为1)所收养，因此init进程此时变成孤儿进程的父进程，并由init进程对它们完成状态收集工作。（linux下，init是内核启动的第一个用户级进程，init有许多很重要的任务，比如像启动getty（用于用户登录）、实现运行级别、以及处理孤立进程。）</p>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程:"></a>守护进程:</h3><p>守护进程也就是通常说的Daemon进程（精灵进程），是Linux中的后台服务进程，是特殊的孤儿进程。生存期较长，通常独立于控制终端（不会因为控制终端被关闭而中断）并且周期性地执行某种任务或等待处理某些发生的事件。举例：nignx、mysql、cron都是守护进程。</p>
<h2 id="6-进程控制"><a href="#6-进程控制" class="headerlink" title="6.进程控制"></a>6.进程控制</h2><h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><p>fork：创建一个子进程，父子进程代码共享，数据独有。(共享是因为页表的权限，独有是不同的页表对应空间存数据)<br>vfork：创建一个子进程，并且阻塞父进程，直到子进程退出或者程序替换，父进程才继续运行</p>
<h3 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h3><p>return：只可以在 main 函数中用，推出后刷新缓冲区<br>exit(statu)：库函数，退出刷新缓冲区<br>_exit(statu)：系统调用，status 定义了进程的终止状态，父进程通过wait来获取该值，退出不刷新缓冲区    </p>
<h3 id="进程等待"><a href="#进程等待" class="headerlink" title="进程等待"></a>进程等待</h3><p>wait：获取退出子进程的pid，并且释放子进程资源。( 阻塞：为了完成某个功能发起调用，如果不具备完成功能的条件，则调用不返回一直等待。非阻塞：为了完成某个功能发起调用，如果不具备完成功能的条件，则立即报错返回 )<br>waitpid：可以指定等待一个子进程的退出</p>
<h3 id="程序替换"><a href="#程序替换" class="headerlink" title="程序替换"></a>程序替换</h3><p>创建的子进程如果想要做与父进程不同的事，其最好的方法就是程序替换，替换一个进程正在调度的程序信息。</p>
<h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>l(list)：表示参数采用列表<br>v(vector)：参数用数组<br>p(path)：有p自动搜索环境变量PATH<br>e(env)：有e表示自己维护环境变量  </p>
<h2 id="7-进程的调度算法"><a href="#7-进程的调度算法" class="headerlink" title="7.进程的调度算法"></a>7.进程的调度算法</h2><p>针对批处理系统：批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p>
<h3 id="1-1先来先服务-first-come-first-serverd（FCFS）"><a href="#1-1先来先服务-first-come-first-serverd（FCFS）" class="headerlink" title="1.1先来先服务 first-come first-serverd（FCFS）"></a>1.1先来先服务 first-come first-serverd（FCFS）</h3><p>非抢占式的调度算法，按照请求的顺序进行调度。有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p>
<h3 id="1-2短作业优先-shortest-job-first（SJF）"><a href="#1-2短作业优先-shortest-job-first（SJF）" class="headerlink" title="1.2短作业优先 shortest job first（SJF）"></a>1.2短作业优先 shortest job first（SJF）</h3><p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。如果一直有短作业到来，长作业可能处于一直等待短作业执行完毕的状态，导致饿死。</p>
<h3 id="1-3最短剩余时间优先-shortest-remaining-time-next（SRTN）"><a href="#1-3最短剩余时间优先-shortest-remaining-time-next（SRTN）" class="headerlink" title="1.3最短剩余时间优先 shortest remaining time next（SRTN）"></a>1.3最短剩余时间优先 shortest remaining time next（SRTN）</h3><p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较，如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。<br>交互式系统：交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p>
<h3 id="2-1时间片轮转"><a href="#2-1时间片轮转" class="headerlink" title="2.1时间片轮转"></a>2.1时间片轮转</h3><p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。时间片轮转算法的效率和时间片的大小有很大关系：<br>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。而如果时间片过长，那么实时性就不能得到保证。</p>
<h3 id="2-2优先级调度"><a href="#2-2优先级调度" class="headerlink" title="2.2优先级调度"></a>2.2优先级调度</h3><p>为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
<h3 id="2-3-多级反馈队列"><a href="#2-3-多级反馈队列" class="headerlink" title="2.3 多级反馈队列"></a>2.3 多级反馈队列</h3><p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xucanxx.github.io/2023/02/10/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-%E8%BF%9B%E7%A8%8B/" data-id="cm8758voc0053657k1tlcbybk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0/" rel="tag">果子私房笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-果子私房笔记-僵尸进程和孤儿进程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/10/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/" class="article-date">
  <time datetime="2023-02-09T22:46:50.000Z" itemprop="datePublished">2023-02-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/10/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/">果子私房笔记-僵尸进程和孤儿进程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="僵尸进程和孤儿进程"><a href="#僵尸进程和孤儿进程" class="headerlink" title="僵尸进程和孤儿进程"></a>僵尸进程和孤儿进程</h1><h2 id="1-什么是进程？"><a href="#1-什么是进程？" class="headerlink" title="1.什么是进程？"></a>1.什么是进程？</h2><p>程序：程序是指令和数据的集合<br>进程：进程就是程序的一次执行过程，是系统进行资源分配和调度的独立单位</p>
<h2 id="2-为什么需要进程？"><a href="#2-为什么需要进程？" class="headerlink" title="2.为什么需要进程？"></a>2.为什么需要进程？</h2><p>引入多道程序技术后为了方便管理，完成对各个程序的并发执行，引入了进程</p>
<h2 id="3-如何操作进程？"><a href="#3-如何操作进程？" class="headerlink" title="3.如何操作进程？"></a>3.如何操作进程？</h2><p>操作系统为了能够使每个程序能够独立运行，在操作系统中为其配置了一个数据结构，也就是我们通常所说的PCB（Process Control Block），PCB 是进程运行相关的信息集合。</p>
<h2 id="孤儿进程："><a href="#孤儿进程：" class="headerlink" title="孤儿进程："></a>孤儿进程：</h2><p>父进程运行结束，但子进程还在运行(未运行结束)的子进程就称为孤儿进程。孤儿进程最终会被init进程(进程号为1)所收养，因此init进程此时变成孤儿进程的父进程，并由init进程对它们完成状态收集工作。（linux下，init是内核启动的第一个用户级进程，init有许多很重要的任务，比如像启动getty（用于用户登录）、实现运行级别、以及处理孤立进程。）</p>
<h2 id="僵尸进程："><a href="#僵尸进程：" class="headerlink" title="僵尸进程："></a>僵尸进程：</h2><p>一个进程使用fork创建子进程，如果子进程退出执行后，父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵死进程。<br>如果进程不调用wait &#x2F; waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。所以僵尸进程是有危害的。</p>
<h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程:"></a>守护进程:</h2><p>守护进程也就是通常说的Daemon进程（精灵进程），是Linux中的后台服务进程，是个特殊的孤儿进程。它是一个生存期较长的进程，通常独立于控制终端（不会因为控制终端被关闭而中断）并且周期性地执行某种任务或等待处理某些发生的事件。举例：nignx、mysql、cron都是守护进程。</p>
<h2 id="父进程、子进程："><a href="#父进程、子进程：" class="headerlink" title="父进程、子进程："></a>父进程、子进程：</h2><p>父进程和子进程的关系是：子进程是父进程的一个副本，一个父进程能创建多个子进程，创建子进程能并发执行。一般来说，子进程先结束执行，然后父进程负责子进程的一些善后工作（回收资源）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xucanxx.github.io/2023/02/10/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/" data-id="cm8758vob004q657k6nf0707j" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0/" rel="tag">果子私房笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-果子私房笔记-多路IO复用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/22/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-%E5%A4%9A%E8%B7%AFIO%E5%A4%8D%E7%94%A8/" class="article-date">
  <time datetime="2023-01-21T23:33:23.000Z" itemprop="datePublished">2023-01-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/22/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-%E5%A4%9A%E8%B7%AFIO%E5%A4%8D%E7%94%A8/">果子私房笔记-多路IO复用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="多路IO复用"><a href="#多路IO复用" class="headerlink" title="多路IO复用"></a>多路IO复用</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_46312987/article/details/124213418">https://blog.csdn.net/qq_46312987/article/details/124213418</a></p>
<h2 id="零拷贝优化"><a href="#零拷贝优化" class="headerlink" title="零拷贝优化"></a>零拷贝优化</h2><p>传统的网络编程中，将磁盘文件写入网卡需要进行四次拷贝和四次上下文切换。<br>磁盘文件–DMA拷贝-&gt;(内核态)缓存区–CPU拷贝-&gt;(用户态)用户缓存区–CPU拷贝-&gt;(内核态)socket缓冲区–DMA拷贝-&gt;网卡。</p>
<h3 id="DMA拷贝："><a href="#DMA拷贝：" class="headerlink" title="DMA拷贝："></a>DMA拷贝：</h3><p>DMA的原理是CPU将需要迁移的数据的位置告诉给DMA，包括源地址，目的地址以及需要迁移的长度，然后启动DMA设备去完成相应的操作，最后通过中断反馈给CPU，结束。</p>
<h3 id="Mmap优化："><a href="#Mmap优化：" class="headerlink" title="Mmap优化："></a>Mmap优化：</h3><p>mmap通过内存映射，将内存缓冲区中的数据映射到用户缓冲区，由此让用户空间共享内核空间的数据。</p>
<h2 id="常用的IO模型"><a href="#常用的IO模型" class="headerlink" title="常用的IO模型"></a>常用的IO模型</h2><h3 id="阻塞IO："><a href="#阻塞IO：" class="headerlink" title="阻塞IO："></a>阻塞IO：</h3><p>假设建立一个socket连接，如果这个连接的客户端一直不发数据，那么服务端线程将会一直阻塞在read函数上不返回。</p>
<h3 id="非阻塞IO："><a href="#非阻塞IO：" class="headerlink" title="非阻塞IO："></a>非阻塞IO：</h3><p>将read函数改造成：如果没有数据到达网卡时，立即返回一个错误值，而不是阻塞地等待。这样就需要用户线程循环调用read，直到返回值不为-1，再开始处理业务。注意：非阻塞的read，指的是数据还未到达网卡，当数据已经到达内核缓冲区，此时调用read函数依旧是阻塞的，需要等待数据从内核缓冲区拷贝到用户缓冲区才能返回。</p>
<h3 id="多路复用IO"><a href="#多路复用IO" class="headerlink" title="多路复用IO"></a>多路复用IO</h3><h4 id="前导："><a href="#前导：" class="headerlink" title="前导："></a>前导：</h4><p>为每个连接创建一个线程耗费的资源较多，我们可以每连接一个客户端后，将文件描述符放到一个数组里，用一个线程不断去遍历这个数组，调用每个元素的非阻塞read方法。每次遍历到read返回-1，依然是一次浪费资源的系统调用。</p>
<h4 id="Select："><a href="#Select：" class="headerlink" title="Select："></a>Select：</h4><p>通过select，我们把文件描述符数组传输给操作系统，让操作系统去遍历，操作系统将准备就绪的文件描述符做上标识再返回给用户，用户依旧需要遍历刚提交给操作系统的数组。相比于前导的方法，就是把循环调用rpc改成了一次调用批量的rpc。</p>
<h4 id="Poll："><a href="#Poll：" class="headerlink" title="Poll："></a>Poll：</h4><p>相比select去掉了只能监听1024个文件描述符的限制。</p>
<h5 id="Epoll："><a href="#Epoll：" class="headerlink" title="Epoll："></a>Epoll：</h5><p>针对select模型的三个缺点进行改造：1.在内核中保存一份文件描述符集合，无需用户每次重新传入，只需告诉内核修改的部分。2.内核不再以轮询的方式去找就绪的文件描述符，而是通过异步IO事件唤醒。3.内核仅会将有IO事件的文件描述符返回给用户，用户无需再遍历整个文件描述符集合。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xucanxx.github.io/2023/01/22/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-%E5%A4%9A%E8%B7%AFIO%E5%A4%8D%E7%94%A8/" data-id="cm8758vob004u657kg2fidha4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0/" rel="tag">果子私房笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Ruby/">Ruby</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/c/">c++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/go/">go</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kafka/">kafka</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/openresty/">openresty</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/shell/">shell</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/">架构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ACM/" rel="tag">ACM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/brpc/" rel="tag">brpc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bug/" rel="tag">bug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0/" rel="tag">果子私房笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9E%8E%E7%8E%A9/" rel="tag">瞎玩</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%80%83%E7%A0%94/" rel="tag">考研</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/ACM/" style="font-size: 18.33px;">ACM</a> <a href="/tags/brpc/" style="font-size: 10px;">brpc</a> <a href="/tags/bug/" style="font-size: 10px;">bug</a> <a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 15px;">基础</a> <a href="/tags/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0/" style="font-size: 20px;">果子私房笔记</a> <a href="/tags/%E6%A1%86%E6%9E%B6/" style="font-size: 10px;">框架</a> <a href="/tags/%E7%9E%8E%E7%8E%A9/" style="font-size: 10px;">瞎玩</a> <a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 16.67px;">笔记</a> <a href="/tags/%E8%80%83%E7%A0%94/" style="font-size: 10px;">考研</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 11.67px;">随笔</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 13.33px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">三月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">四月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">一月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">十二月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">九月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">七月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">三月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">十二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/03/13/Linux/">Linux要点</a>
          </li>
        
          <li>
            <a href="/2025/03/13/c++/">C++要点</a>
          </li>
        
          <li>
            <a href="/2025/03/13/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>
          </li>
        
          <li>
            <a href="/2025/03/13/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>
          </li>
        
          <li>
            <a href="/2025/03/13/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E6%88%96%E7%BB%84%E4%BB%B6/">开源框架或组件</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2025 xucanxx<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>