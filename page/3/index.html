<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>咸鱼</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="I good vegetable a">
<meta property="og:type" content="website">
<meta property="og:title" content="咸鱼">
<meta property="og:url" content="https://xucanxx.github.io/page/3/index.html">
<meta property="og:site_name" content="咸鱼">
<meta property="og:description" content="I good vegetable a">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="xucanxx">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="咸鱼" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">咸鱼</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://xucanxx.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-果子私房笔记-time_wait" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/22/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-time_wait/" class="article-date">
  <time datetime="2023-01-21T23:28:48.000Z" itemprop="datePublished">2023-01-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/22/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-time_wait/">果子私房笔记-time_wait</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="time-wait"><a href="#time-wait" class="headerlink" title="time_wait"></a>time_wait</h1><h2 id="time-wait状态如何产生？"><a href="#time-wait状态如何产生？" class="headerlink" title="time_wait状态如何产生？"></a>time_wait状态如何产生？</h2><p>由上面的变迁图，首先调用close()发起主动关闭的一方，在发送最后一个ACK之后会进入time_wait的状态，也就说该发送方会保持2MSL时间之后才会回到初始状态。MSL值得是数据包在网络中的最大生存时间。产生这种结果使得这个TCP连接在2MSL连接等待期间，定义这个连接的四元组（客户端IP地址和端口，服务端IP地址和端口号）不能被使用。</p>
<h2 id="time-wait状态产生的原因"><a href="#time-wait状态产生的原因" class="headerlink" title="time_wait状态产生的原因"></a>time_wait状态产生的原因</h2><h3 id="1）为实现TCP全双工连接的可靠释放"><a href="#1）为实现TCP全双工连接的可靠释放" class="headerlink" title="1）为实现TCP全双工连接的可靠释放"></a>1）为实现TCP全双工连接的可靠释放</h3><p>假设发起主动关闭的一方（client）最后发送的ACK在网络中丢失，由于TCP协议的重传机制，执行被动关闭的一方（server）将会重发其FIN，在该FIN到达client之前，client必须维护这条连接状态，也就说这条TCP连接所对应的资源（client方的local_ip,local_port）不能被立即释放或重新分配，直到另一方重发的FIN达到之后，client重发ACK后，经过2MSL时间周期没有再收到另一方的FIN之后，该TCP连接才能恢复初始的CLOSED状态。如果主动关闭一方不维护这样一个TIME_WAIT状态，那么当被动关闭一方重发的FIN到达时，主动关闭一方的TCP传输层会用RST包响应对方，这会被对方认为是有错误发生，然而这事实上只是正常的关闭连接过程，并非异常。</p>
<h3 id="2）为使旧的数据包在网络因过期而消失"><a href="#2）为使旧的数据包在网络因过期而消失" class="headerlink" title="2）为使旧的数据包在网络因过期而消失"></a>2）为使旧的数据包在网络因过期而消失</h3><p>为说明这个问题，我们先假设TCP协议中不存在TIME_WAIT状态的限制，再假设当前有一条TCP连接：(local_ip, local_port, remote_ip,remote_port)，因某些原因，我们先关闭，接着很快以相同的四元组建立一条新连接。本文前面介绍过，TCP连接由四元组唯一标识，因此，在我们假设的情况中，TCP协议栈是无法区分前后两条TCP连接的不同的，在它看来，这根本就是同一条连接，中间先释放再建立的过程对其来说是“感知”不到的。这样就可能发生这样的情况：前一条TCP连接由local peer发送的数据到达remote peer后，会被该remot peer的TCP传输层当做当前TCP连接的正常数据接收并向上传递至应用层（而事实上，在我们假设的场景下，这些旧数据到达remote peer前，旧连接已断开且一条由相同四元组构成的新TCP连接已建立，因此，这些旧数据是不应该被向上传递至应用层的），从而引起数据错乱进而导致各种无法预知的诡异现象。作为一种可靠的传输协议，TCP必须在协议层面考虑并避免这种情况的发生，这正是TIME_WAIT状态存在的第2个原因。</p>
<h3 id="3）总结"><a href="#3）总结" class="headerlink" title="3）总结"></a>3）总结</h3><p>具体而言，local peer主动调用close后，此时的TCP连接进入TIME_WAIT状态，处于该状态下的TCP连接不能立即以同样的四元组建立新连接，即发起active close的那方占用的local port在TIME_WAIT期间不能再被重新分配。由于TIME_WAIT状态持续时间为2MSL，这样保证了旧TCP连接双工链路中的旧数据包均因过期（超过MSL）而消失，此后，就可以用相同的四元组建立一条新连接而不会发生前后两次连接数据错乱的情况。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xucanxx.github.io/2023/01/22/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-time_wait/" data-id="cm8758voa004n657k9k4m9o63" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0/" rel="tag">果子私房笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-果子私房笔记-TCP握手挥手数据传输" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/22/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-TCP%E6%8F%A1%E6%89%8B%E6%8C%A5%E6%89%8B%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/" class="article-date">
  <time datetime="2023-01-21T22:46:23.000Z" itemprop="datePublished">2023-01-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/22/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-TCP%E6%8F%A1%E6%89%8B%E6%8C%A5%E6%89%8B%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/">果子私房笔记-TCP握手挥手数据传输</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="TCP握手挥手数据传输"><a href="#TCP握手挥手数据传输" class="headerlink" title="TCP握手挥手数据传输"></a>TCP握手挥手数据传输</h1><h2 id="三次握手过程"><a href="#三次握手过程" class="headerlink" title="三次握手过程"></a>三次握手过程</h2><h3 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h3><p>客户端发送syn包(seq&#x3D;x)到服务器，并进入SYN_SEND状态(请求连接)，等待服务器确认</p>
<h3 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h3><p>服务器收到syn包，必须确认客户的SYN(ack&#x3D;x+1)，同时自己也发送一个SYN包(seq&#x3D;y)，即SYN+ACK包，此时服务器进入SYN_RECV状态(接收到SYN的状态，连接套接字状态);</p>
<h3 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h3><p>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack&#x3D;y+1)，此包发送完毕并完成接收后，客户端和服务器进入ESTABLISHED状态(已经建立了连接状态)，完成三次握手。</p>
<p>SYN：同步序列编号(Synchronize Sequence Numbers)，是TCP&#x2F;IP建立连接时使用的握手信号。<br>ACK：确认字符(Acknowledge character)，在数据通信中，接收站发给发送站的一种传输类控制字符，表示发来的数据已确认接收无误。</p>
<p>第三次握手就是为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误。</p>
<h2 id="传输数据过程"><a href="#传输数据过程" class="headerlink" title="传输数据过程"></a>传输数据过程</h2><h3 id="a-超时重传："><a href="#a-超时重传：" class="headerlink" title="a.超时重传："></a>a.超时重传：</h3><p>超时重传机制用来保证TCP传输的可靠性。每次发送数据包时，发送的数据报都有seq号，接收端收到数据后，会回复ack进行确认，表示某一seq号数据已经收到。发送方在发送了某个seq包后，等待一段时间，如果没有收到对应的ack回复，就会认为报文丢失，会重传这个数据包。</p>
<h3 id="b-快速重传："><a href="#b-快速重传：" class="headerlink" title="b.快速重传："></a>b.快速重传：</h3><p>接受数据一方发现有数据包丢掉了。就会发送ack报文告诉发送端重传丢失的报文。如果发送端连续收到标号相同的ack包，则会触发客户端的快速重传。比较超时重传和快速重传，可以发现超时重传是发送端在傻等超时，然后触发重传;而快速重传则是接收端主动告诉发送端数据没收到，然后触发发送端重传。</p>
<h3 id="c-流量控制："><a href="#c-流量控制：" class="headerlink" title="c.流量控制："></a>c.流量控制：</h3><p>这里主要说TCP滑动窗流量控制。TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是接收端告诉发送端自己 还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。 滑动窗可以是提高TCP传输效率的一种机制。</p>
<h3 id="d-拥塞控制："><a href="#d-拥塞控制：" class="headerlink" title="d.拥塞控制："></a>d.拥塞控制：</h3><p>滑动窗用来做流量控制。流量控制只关注发送端和接受端自身的状况，而没有考虑整个网络的通信情况。拥塞控制，则是基于整个网络来考虑的。考虑一下这 样的场景：某一时刻网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多 的丢包，于是，这个情况就会进入恶性循环被不断地放大。试想一下，如果一个网络内有成千上万的TCP连接都这么行事，那么马上就会形成“网络风暴”，TCP这个协议就会拖垮整个网络。为此，TCP引入了拥塞控制策略。拥塞策略算法主要包括：慢启动，拥塞避免，拥塞发生，快速恢复。</p>
<h2 id="四次挥手过程"><a href="#四次挥手过程" class="headerlink" title="四次挥手过程"></a>四次挥手过程</h2><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p>
<h3 id="（1）-TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送。"><a href="#（1）-TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送。" class="headerlink" title="（1） TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送。"></a>（1） TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送。</h3><h3 id="（2）-服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。"><a href="#（2）-服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。" class="headerlink" title="（2） 服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。"></a>（2） 服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。</h3><h3 id="（3）-服务器关闭客户端的连接，发送一个FIN给客户端。"><a href="#（3）-服务器关闭客户端的连接，发送一个FIN给客户端。" class="headerlink" title="（3） 服务器关闭客户端的连接，发送一个FIN给客户端。"></a>（3） 服务器关闭客户端的连接，发送一个FIN给客户端。</h3><h3 id="（4）-客户端发回ACK报文确认，并将确认序号设置为收到序号加1。"><a href="#（4）-客户端发回ACK报文确认，并将确认序号设置为收到序号加1。" class="headerlink" title="（4） 客户端发回ACK报文确认，并将确认序号设置为收到序号加1。"></a>（4） 客户端发回ACK报文确认，并将确认序号设置为收到序号加1。</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://xucanxx.github.io/2023/01/22/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-TCP%E6%8F%A1%E6%89%8B%E6%8C%A5%E6%89%8B%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/" data-id="cm8758vo80043657k1t1eabxy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0/" rel="tag">果子私房笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-go的多进程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/11/go%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B/" class="article-date">
  <time datetime="2023-01-11T07:11:54.000Z" itemprop="datePublished">2023-01-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/go/">go</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/11/go%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B/">go的多进程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="go的多进程"><a href="#go的多进程" class="headerlink" title="go的多进程"></a>go的多进程</h1><p>虽然说可以直接用go的协程直接起子进程，但是为了保证当起子进程时父类的结构尽可能简单，变采用主进程起子进程的形式</p>
<h2 id="异步起进程"><a href="#异步起进程" class="headerlink" title="异步起进程"></a>异步起进程</h2><p>主进程起进程，起协程监听子进程的执行情况，可以使后台的子进程跑满制定数量</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">package main

import (
	&quot;log&quot;
	&quot;os&quot;
	&quot;strconv&quot;
)

var processChan &#x3D; make(chan int, 10)

func processListen(process *os.Process) &#123;
	p, _ :&#x3D; process.Wait()
	exitCode :&#x3D; p.ExitCode()
	log.Println(&quot;process finish ExitCode: &quot;, exitCode)
	&lt;-processChan
&#125;

func main() &#123;
	poolsize :&#x3D; 8
	for &#123;
		for len(processChan) &lt; poolsize &#123;

			procAttr :&#x3D; &amp;os.ProcAttr&#123;
					Files: []*os.File&#123;os.Stdin, os.Stdout, os.Stderr&#125;,
					Sys: &amp;syscall.SysProcAttr&#123;
						&#x2F;&#x2F;将子进程与主进程设置为同一个进程组，当主进程退出，或者崩溃，子进程将一并退出
						Setpgid:   true,
						Pdeathsig: syscall.SIGKILL,
					&#125;,
				&#125;
			process, err :&#x3D; os.StartProcess(&quot;&#x2F;bin&#x2F;bash&quot;, []string&#123;&quot;bash&quot;, &quot;-c&quot;, &quot;echo processChan size: &quot; + strconv.Itoa(len(processChan))&#125;, procAttr)
			if err !&#x3D; nil &#123;
				log.Println(&quot;StartProcess err: &quot;, err)
				continue
			&#125;
			processChan &lt;- -1
			go processListen(process)
		&#125;
	&#125;

&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="分批同步起线程"><a href="#分批同步起线程" class="headerlink" title="分批同步起线程"></a>分批同步起线程</h2><p>每次都起poolsize数量的进程，当后台的子进程全执行完之后，再起新的一批</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">package main

import (
	&quot;os&quot;
)
func main() &#123;
	poolsize :&#x3D; 8
	for &#123;
		for i:&#x3D; 0; i &lt; poolsize ;i++&#123;
			var processId []*os.Process	
			var size int
			procAttr :&#x3D; &amp;os.ProcAttr&#123;
						Files: []*os.File&#123;os.Stdin, os.Stdout, os.Stderr&#125;,
						Sys: &amp;syscall.SysProcAttr&#123;
							&#x2F;&#x2F;将子进程与主进程设置为同一个进程组，当主进程退出，或者崩溃，子进程将一并退出
							Setpgid:   true,
							Pdeathsig: syscall.SIGKILL,
						&#125;,
					&#125;

			process, err :&#x3D; os.StartProcess(&quot;&#x2F;bin&#x2F;bash&quot;, []string&#123;&quot;bash&quot;, &quot;-c&quot;, &quot;echo process start&quot;&#125;, procAttr)

			if err !&#x3D; nil &#123;
				log.Println(&quot;StartProcess err: &quot;, err)
				ifsuccess &#x3D; 0
				continue
			&#125;
			size++
			processId &#x3D; append(processId, process)
		&#125;
		for size &gt; 0 &#123;
			p, _ :&#x3D; processId[size-1].Wait()
			exitCode :&#x3D; p.ExitCode()
			size--
			log.Println(&quot;exitCode: &quot;, exitCode)
		&#125;
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><h3 id="exec-Commond"><a href="#exec-Commond" class="headerlink" title="exec.Commond"></a>exec.Commond</h3><p>也可以使用exec.Commond 但是cmd结构体中的process不能外部访问，我不知道怎么用这个获取进程的exitcode，所以没用。</p>
<h3 id="os-ProcessState-kill"><a href="#os-ProcessState-kill" class="headerlink" title="os.ProcessState.kill()"></a>os.ProcessState.kill()</h3><p>当执行这个自带的kill函数后向子进程发送的并不是 kill 信号 而是kill -9 这将导致子进程占用的资源不会被正常释放，从而变成僵尸进程</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xucanxx.github.io/2023/01/11/go%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B/" data-id="cm8758vnx0016657k8b2ydzjm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-果子私房笔记-TCP与UDP的区别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/12/15/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB/" class="article-date">
  <time datetime="2022-12-15T01:36:06.000Z" itemprop="datePublished">2022-12-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/12/15/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB/">果子私房笔记-TCP与UDP的区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h1><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="TCP的优点："><a href="#TCP的优点：" class="headerlink" title="TCP的优点："></a>TCP的优点：</h3><p>可靠，稳定 TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。 </p>
<h3 id="TCP的缺点："><a href="#TCP的缺点：" class="headerlink" title="TCP的缺点："></a>TCP的缺点：</h3><p>慢，效率低，占用系统资源高，易被攻击TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。 而且，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。</p>
<h3 id="什么时候应该使用TCP："><a href="#什么时候应该使用TCP：" class="headerlink" title="什么时候应该使用TCP："></a>什么时候应该使用TCP：</h3><p>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Telnet、SSH QQ文件传输</p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h3 id="UDP的优点："><a href="#UDP的优点：" class="headerlink" title="UDP的优点："></a>UDP的优点：</h3><p>快，比TCP稍安全 UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击。</p>
<h3 id="UDP的缺点："><a href="#UDP的缺点：" class="headerlink" title="UDP的缺点："></a>UDP的缺点：</h3><p>不可靠，不稳定<br>因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。 </p>
<h3 id="什么时候应该使用UDP："><a href="#什么时候应该使用UDP：" class="headerlink" title="什么时候应该使用UDP："></a>什么时候应该使用UDP：</h3><p>当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。<br>比如，日常生活中，常见使用UDP协议的应用如下： QQ语音 QQ视频 TFTP </p>
<h2 id="小结TCP与UDP的区别："><a href="#小结TCP与UDP的区别：" class="headerlink" title="小结TCP与UDP的区别："></a>小结TCP与UDP的区别：</h2><p>1.基于连接与无连接；<br>2.对系统资源的要求（TCP较多，UDP少）；<br>3.UDP程序结构较简单；<br>4.流模式与数据报模式 ；<br>5.TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。</p>
<table>
<thead>
<tr>
<th align="center">tcp协议和udp协议的差别</th>
</tr>
</thead>
</table>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">TCP</th>
<th align="center">UDP</th>
</tr>
</thead>
<tbody><tr>
<td align="center">是否连接</td>
<td align="center">面向连接</td>
<td align="center">面向非连接</td>
</tr>
<tr>
<td align="center">传输可靠性</td>
<td align="center">可靠</td>
<td align="center">不可靠 （可靠的UDP基于应用层实现）</td>
</tr>
<tr>
<td align="center">应用场合</td>
<td align="center">少量数据</td>
<td align="center">传输大量数据</td>
</tr>
<tr>
<td align="center">速度</td>
<td align="center">慢</td>
<td align="center">快</td>
</tr>
</tbody></table>
<h2 id="TCP与UDP区别总结："><a href="#TCP与UDP区别总结：" class="headerlink" title="TCP与UDP区别总结："></a>TCP与UDP区别总结：</h2><p>1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接</p>
<p>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</p>
<p>3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的</p>
<p>UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</p>
<p>4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</p>
<p>5、TCP首部开销20字节;UDP的首部开销小，只有8个字节，其中有2个byte用于记录包体长度因此包最大大小为64k。</p>
<p>6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</p>
<p>问：.tcp如何可靠<br>    应答机制&#x2F;拥塞控制&#x2F;流量控制&#x2F;重复丢弃&#x2F;失序重排&#x2F;超时重传</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xucanxx.github.io/2022/12/15/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB/" data-id="cm8758vo7003w657k8ykmhssa" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0/" rel="tag">果子私房笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-果子私房笔记-SSL握手过程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/12/15/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-SSL%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/" class="article-date">
  <time datetime="2022-12-15T01:14:35.000Z" itemprop="datePublished">2022-12-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/12/15/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-SSL%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/">果子私房笔记-SSL握手过程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="SSL握手过程"><a href="#SSL握手过程" class="headerlink" title="SSL握手过程"></a>SSL握手过程</h1><h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>SSL握手过程的本质是在协商对称加密的秘钥。HTTPS协议的安全机制是靠SSL来实现的（SSL位于应用层和传输层之间）</p>
<p>为了保证数据的安全性，在数据发送前需要对数据进行加密。传统的对称加密，协商秘钥过程如果被窃听导致秘钥泄露，加密的数据也就变得“公开透明”了，而使用非对称加密的方式效率较低。因此，在SSL中采用“对称加密个非对称加密结合”的方法保证数据的安全性，即非对称加密进行对称加密秘钥的协商，而这个协商过程就可以认为是SSL握手。</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>1.客户端给服务器端发送协议版本、客户端支持的加密算法、一个随机数1。<br>2.服务器端选择加密算法，并向客户端发送一个服务器数字证书和一个随机数2。<br>3.客户端使用数字证书中的公钥，将随机数3加密发送给服务器。<br>4.服务器使用私钥对随机数字3解密。<br>5.服务器端和客户端通过事先协商好的加密算法，对这三个随机数进行加密生成“对话秘钥”（session key）即对称加密的秘钥，用于接下来整个对话过程的加密。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xucanxx.github.io/2022/12/15/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-SSL%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/" data-id="cm8758vo7003s657k068ncnc9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0/" rel="tag">果子私房笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-果子私房笔记-http协议无状态协议以及解决方案" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/12/15/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-http%E5%8D%8F%E8%AE%AE%E6%97%A0%E7%8A%B6%E6%80%81%E5%8D%8F%E8%AE%AE%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" class="article-date">
  <time datetime="2022-12-15T01:12:41.000Z" itemprop="datePublished">2022-12-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/12/15/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-http%E5%8D%8F%E8%AE%AE%E6%97%A0%E7%8A%B6%E6%80%81%E5%8D%8F%E8%AE%AE%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">果子私房笔记-http协议无状态协议以及解决方案</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="http协议无状态协议以及解决方案"><a href="#http协议无状态协议以及解决方案" class="headerlink" title="http协议无状态协议以及解决方案"></a>http协议无状态协议以及解决方案</h1><p>http本身是一种无状态协议</p>
<p>无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息<br>也就是说，当客户端一次HTTP请求完成以后，客户端再发送一次HTTP请求，HTTP并不知道当前客户端是一个”老用户“。</p>
<p>可以使用Cookie来解决无状态的问题，Cookie就相当于一个通行证，第一次访问的时候给客户端发送一个Cookie，当客户端再次来的时候，拿着Cookie(通行证)，那么服务器就知道这个是”老用户“。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xucanxx.github.io/2022/12/15/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-http%E5%8D%8F%E8%AE%AE%E6%97%A0%E7%8A%B6%E6%80%81%E5%8D%8F%E8%AE%AE%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" data-id="cm8758vo90049657k0c8m8e2c" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0/" rel="tag">果子私房笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-果子私房笔记-http与https的区别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/12/15/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-http%E4%B8%8Ehttps%E7%9A%84%E5%8C%BA%E5%88%AB/" class="article-date">
  <time datetime="2022-12-15T01:06:56.000Z" itemprop="datePublished">2022-12-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/12/15/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-http%E4%B8%8Ehttps%E7%9A%84%E5%8C%BA%E5%88%AB/">果子私房笔记-http与https的区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="http与https的区别"><a href="#http与https的区别" class="headerlink" title="http与https的区别"></a>http与https的区别</h1><p>HTTP的URL以http:&#x2F;&#x2F; 开头，而HTTPS 的URL 以https:&#x2F;&#x2F;开头<br>HTTP是不安全的，而HTTPS是安全的<br>HTTP标准端口是80 ，而HTTPS的标准端口是443<br>在OSI网络模型中，HTTP工作于应用层，而HTTPS的安全传输机制工作在传输层<br>HTTP无法加密，而HTTPS对传输的数据进行加密<br>HTTP无需证书，而HTTPS需要CA机构wosign的颁发的SSL证书</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xucanxx.github.io/2022/12/15/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-http%E4%B8%8Ehttps%E7%9A%84%E5%8C%BA%E5%88%AB/" data-id="cm8758vo80045657kfqisdcms" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0/" rel="tag">果子私房笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-C++11中的constexpr" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/12/14/C++11%E4%B8%AD%E7%9A%84constexpr/" class="article-date">
  <time datetime="2022-12-13T17:42:14.000Z" itemprop="datePublished">2022-12-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/c/">c++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/12/14/C++11%E4%B8%AD%E7%9A%84constexpr/">C++11中的constexpr</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="C-11中的constexpr"><a href="#C-11中的constexpr" class="headerlink" title="C++11中的constexpr"></a>C++11中的constexpr</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_52902391/article/details/120308866">https://blog.csdn.net/m0_52902391/article/details/120308866</a></p>
<h2 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h2><pre><code>值不会改变且在编译期就能得到计算结果的表达式。
字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。
</code></pre>
<h2 id="constexpr-与-const"><a href="#constexpr-与-const" class="headerlink" title="constexpr 与 const"></a>constexpr 与 const</h2><p> 在定义常量时，const 和 constexpr 是等价的，都可以在程序的编译阶段计算出结果 都为常量表达式<br> 但是const可以修饰函数的传入参数为只读（并非常量），而constexpr无法修饰<br> <pre class="line-numbers language-C++" data-language="C++"><code class="language-C++"> &#x2F;&#x2F; error
void func1(constexpr int p) &#123;

&#125;


&#x2F;&#x2F; ok
void func2(const int p) &#123;

&#125;


void func3(const int p) &#123;
    int a[p];&#x2F;&#x2F;error ,此时p并非常量表达式，只是只读参数
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>
<h2 id="用constexpr修饰函数"><a href="#用constexpr修饰函数" class="headerlink" title="用constexpr修饰函数"></a>用constexpr修饰函数</h2><p>constexpr 并不能修改任意函数的返回值，这些函数成为常量表达式函数时，必须要满足以下几个条件：<br>（这些规则不仅对应普通函数适用，对应类的成员函数也是适用的）  </p>
<h3 id="1-函数必须要有返回值，并且-return-返回的表达式必须是常量表达式。"><a href="#1-函数必须要有返回值，并且-return-返回的表达式必须是常量表达式。" class="headerlink" title="1.函数必须要有返回值，并且 return 返回的表达式必须是常量表达式。"></a>1.函数必须要有返回值，并且 return 返回的表达式必须是常量表达式。</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; error，不是常量表达式函数
constexpr void func1()
&#123;
    int a &#x3D; 100;
    cout &lt;&lt; &quot;a: &quot; &lt;&lt; a &lt;&lt; endl;
&#125;
 
&#x2F;&#x2F; error，不是常量表达式函数
constexpr int func2()
&#123;
    int a &#x3D; 100;
    return a;
&#125;

&#x2F;&#x2F; ok
constexpr int func3()
&#123;
    constexpr int a &#x3D; 100;
    return a;
&#125;
 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>函数 func1() 没有返回值，不满足常量表达式函数要求<br>函数 func2() 返回值不是常量表达式，不满足常量表达式函数要求  </p>
<h3 id="2-整个函数的函数体中，不能出现非常量表达式之外的语句（using-指令、typedef-语句以及-static-assert-断言、return-语句除外）。"><a href="#2-整个函数的函数体中，不能出现非常量表达式之外的语句（using-指令、typedef-语句以及-static-assert-断言、return-语句除外）。" class="headerlink" title="2.整个函数的函数体中，不能出现非常量表达式之外的语句（using 指令、typedef 语句以及 static_assert 断言、return 语句除外）。"></a>2.整个函数的函数体中，不能出现非常量表达式之外的语句（using 指令、typedef 语句以及 static_assert 断言、return 语句除外）。</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; error
constexpr int func1()
&#123;
    constexpr int a &#x3D; 100;
    constexpr int b &#x3D; 10;
    for (int i &#x3D; 0; i &lt; b; ++i)
    &#123;
        cout &lt;&lt; &quot;i: &quot; &lt;&lt; i &lt;&lt; endl;
    &#125;
    return a + b;
&#125;
 
&#x2F;&#x2F; ok
constexpr int func2()
&#123;
    using mytype &#x3D; int;
    constexpr mytype a &#x3D; 100;
    constexpr mytype b &#x3D; 10;
    constexpr mytype c &#x3D; a * b;
    return c - (a + b);
&#125;
 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="修饰模板函数"><a href="#修饰模板函数" class="headerlink" title="修饰模板函数"></a>修饰模板函数</h2><p>C++11 语法中，constexpr 可以修饰函数模板，但由于模板中类型的不确定性，因此函数模板实例化后的模板函数是否符合常量表达式函数的要求也是不确定的。如果 constexpr 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 constexpr 会被自动忽略，即该函数就等同于一个普通函数。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">
#include&lt; iostream &gt;
using namespace std;
 
struct Person &#123;
    const char* name;
    int age;
&#125;;
 
&#x2F;&#x2F; 定义函数模板
template&lt; typename T &gt;
constexpr T dispaly(T t) &#123;
    return t;
&#125;
 
int main()
&#123;
    struct Person p &#123; &quot;luffy&quot;, 19 &#125;;
    &#x2F;&#x2F;普通函数
    struct Person ret &#x3D; dispaly(p);
    cout &lt;&lt; &quot;luffy&#39;s name: &quot; &lt;&lt; ret.name &lt;&lt; &quot;, age: &quot; &lt;&lt; ret.age &lt;&lt; endl;
 
    &#x2F;&#x2F;常量表达式函数
    constexpr int ret1 &#x3D; dispaly(250);
    cout &lt;&lt; ret1 &lt;&lt; endl;
 
    constexpr struct Person p1 &#123; &quot;luffy&quot;, 19 &#125;;
    constexpr struct Person p2 &#x3D; dispaly(p1);
    cout &lt;&lt; &quot;luffy&#39;s name: &quot; &lt;&lt; p2.name &lt;&lt; &quot;, age: &quot; &lt;&lt; p2.age &lt;&lt; endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上面示例程序中定义了一个函数模板 display()，但由于其返回值类型未定，因此在实例化之前无法判断其是否符合常量表达式函数的要求：</p>
<p>struct Person ret &#x3D; dispaly(p); 由于参数 p 是变量，所以实例化后的函数不是常量表达式函数，此时 constexpr 是无效的<br>constexpr int ret1 &#x3D; dispaly(250); 参数是常量，符合常量表达式函数的要求，此时 constexpr 是有效的<br>constexpr struct Person p2 &#x3D; dispaly(p1); 参数是常量，符合常量表达式函数的要求，此时 constexpr 是有效的  </p>
<h2 id="修饰构造函数"><a href="#修饰构造函数" class="headerlink" title="修饰构造函数"></a>修饰构造函数</h2><p>如果想用直接得到一个常量对象，也可以使用 constexpr 修饰一个构造函数，这样就可以得到一个常量构造函数了。常量构造函数有一个要求：构造函数的函数体必须为空，并且必须采用初始化列表的方式为各个成员赋值。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt; iostream &gt;
using namespace std;
 
struct Person &#123;
    constexpr Person(const char* p, int age) :name(p), age(age)
    &#123;
    &#125;
    const char* name;
    int age;
&#125;;
 
int main()
&#123;
    constexpr struct Person p1(&quot;luffy&quot;, 19);
    cout &lt;&lt; &quot;luffy&#39;s name: &quot; &lt;&lt; p1.name &lt;&lt; &quot;, age: &quot; &lt;&lt; p1.age &lt;&lt; endl;
    return 0;
&#125;
 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="注"><a href="#注" class="headerlink" title="注:"></a>注:</h2><h3 id="1-const用于修饰不能被修改的对象，但const对象的值通常在程序运行期间才能确定"><a href="#1-const用于修饰不能被修改的对象，但const对象的值通常在程序运行期间才能确定" class="headerlink" title="1.const用于修饰不能被修改的对象，但const对象的值通常在程序运行期间才能确定"></a>1.const用于修饰不能被修改的对象，但const对象的值通常在程序运行期间才能确定</h3><h3 id="2-constexpr用于修饰常量表达式或可返回常量表达式的constexpr函数，在编译时能确定值。"><a href="#2-constexpr用于修饰常量表达式或可返回常量表达式的constexpr函数，在编译时能确定值。" class="headerlink" title="2.constexpr用于修饰常量表达式或可返回常量表达式的constexpr函数，在编译时能确定值。"></a>2.constexpr用于修饰常量表达式或可返回常量表达式的constexpr函数，在编译时能确定值。</h3><h3 id="3-constexpr函数都是inline函数"><a href="#3-constexpr函数都是inline函数" class="headerlink" title="3.constexpr函数都是inline函数"></a>3.constexpr函数都是inline函数</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://xucanxx.github.io/2022/12/14/C++11%E4%B8%AD%E7%9A%84constexpr/" data-id="cm8758vnn0001657kf5esgmjp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-kafka日常操作" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/12/13/kafka%E6%97%A5%E5%B8%B8%E6%93%8D%E4%BD%9C/" class="article-date">
  <time datetime="2022-12-13T00:15:34.000Z" itemprop="datePublished">2022-12-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/kafka/">kafka</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/12/13/kafka%E6%97%A5%E5%B8%B8%E6%93%8D%E4%BD%9C/">kafka日常操作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="kafka日常操作"><a href="#kafka日常操作" class="headerlink" title="kafka日常操作"></a>kafka日常操作</h1><h2 id="kafka查看数据"><a href="#kafka查看数据" class="headerlink" title="kafka查看数据"></a>kafka查看数据</h2><h3 id="查看所有topic"><a href="#查看所有topic" class="headerlink" title="查看所有topic"></a>查看所有topic</h3><pre><code>./kafka-topics.sh --bootstrap-server 127.0.0.1:9092 --list
</code></pre>
<h3 id="查看所有group"><a href="#查看所有group" class="headerlink" title="查看所有group"></a>查看所有group</h3><pre><code>./kafka-consumer-groups.sh --bootstrap-server 127.0.0.1:9092 --list
</code></pre>
<h3 id="查看指定topic的订阅信息"><a href="#查看指定topic的订阅信息" class="headerlink" title="查看指定topic的订阅信息"></a>查看指定topic的订阅信息</h3><pre><code>./kafka-topics.sh --describe --zookeeper 127.0.0.1:2181 --topic XXXXX
</code></pre>
<h3 id="消费指定group的订阅信息"><a href="#消费指定group的订阅信息" class="headerlink" title="消费指定group的订阅信息"></a>消费指定group的订阅信息</h3><pre><code>./kafka-consumer-groups.sh --bootstrap-server 127.0.0.1:9092 --group XXXXX --describe
</code></pre>
<h3 id="查看从当前当前开始到结束，kafka中指定topic接收到的信息"><a href="#查看从当前当前开始到结束，kafka中指定topic接收到的信息" class="headerlink" title="查看从当前当前开始到结束，kafka中指定topic接收到的信息"></a>查看从当前当前开始到结束，kafka中指定topic接收到的信息</h3><pre><code>./kafka-console-consumer.sh --bootstrap-server 127.0.0.1:9092 --topic XXXXX
</code></pre>
<h3 id="查看所有kafka中接收到的信息"><a href="#查看所有kafka中接收到的信息" class="headerlink" title="查看所有kafka中接收到的信息"></a>查看所有kafka中接收到的信息</h3><pre><code>./kafka-console-consumer.sh --bootstrap-server 127.0.0.1:9092 --topic XXXXX --from-beginning
</code></pre>
<h2 id="kafka创建指令"><a href="#kafka创建指令" class="headerlink" title="kafka创建指令"></a>kafka创建指令</h2><h3 id="kafka创建topic"><a href="#kafka创建topic" class="headerlink" title="kafka创建topic"></a>kafka创建topic</h3><pre><code>./kafka-topics.sh --create --zookeeper 127.0.0.1:2181 --replication-factor 1 --partitions 1 --topic XXXXX
</code></pre>
<h2 id="kafka启动命令"><a href="#kafka启动命令" class="headerlink" title="kafka启动命令"></a>kafka启动命令</h2><h3 id="前台启动"><a href="#前台启动" class="headerlink" title="前台启动"></a>前台启动</h3><pre><code>./bin/kafka-server-start.sh ./config/server.properties
</code></pre>
<h3 id="后台启动"><a href="#后台启动" class="headerlink" title="后台启动"></a>后台启动</h3><pre><code>nohup ./bin/kafka-server-start.sh ./config/server.properties &gt;&gt; ./kafka-server.log 2&gt;&amp;1 &amp;
</code></pre>
<h2 id="kafka关闭命令"><a href="#kafka关闭命令" class="headerlink" title="kafka关闭命令"></a>kafka关闭命令</h2><pre><code>./bin/kafka-server-stop.sh
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xucanxx.github.io/2022/12/13/kafka%E6%97%A5%E5%B8%B8%E6%93%8D%E4%BD%9C/" data-id="cm8758vny001d657kfih43rus" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-果子私房笔记-http的URI和URL" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/12/06/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-http%E7%9A%84URI%E5%92%8CURL/" class="article-date">
  <time datetime="2022-12-06T03:41:42.000Z" itemprop="datePublished">2022-12-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/12/06/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-http%E7%9A%84URI%E5%92%8CURL/">果子私房笔记-http的URI和URL</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h1><p>URI是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。就是由某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称。采用HTTP协议时，协议方案就是http。除此之外，还有ftp、mailto、telnet、file等。</p>
<p>Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的</p>
<h2 id="URI一般由三部组成："><a href="#URI一般由三部组成：" class="headerlink" title="URI一般由三部组成："></a>URI一般由三部组成：</h2><h3 id="①访问资源的命名机制"><a href="#①访问资源的命名机制" class="headerlink" title="①访问资源的命名机制"></a>①访问资源的命名机制</h3><h3 id="②存放资源的主机名"><a href="#②存放资源的主机名" class="headerlink" title="②存放资源的主机名"></a>②存放资源的主机名</h3><h3 id="③资源自身的名称，由路径表示，着重强调于资源。"><a href="#③资源自身的名称，由路径表示，着重强调于资源。" class="headerlink" title="③资源自身的名称，由路径表示，着重强调于资源。"></a>③资源自身的名称，由路径表示，着重强调于资源。</h3><h1 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h1><p>URL是uniform resource locator，统一资源定位器，表示资源的地点。可见 URL是 URI 的子集。<br>URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。<br>采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。</p>
<h2 id="URL一般由三部组成："><a href="#URL一般由三部组成：" class="headerlink" title="URL一般由三部组成："></a>URL一般由三部组成：</h2><h3 id="①协议-或称为服务方式"><a href="#①协议-或称为服务方式" class="headerlink" title="①协议(或称为服务方式)"></a>①协议(或称为服务方式)</h3><h3 id="②存有该资源的主机IP地址-有时也包括端口号"><a href="#②存有该资源的主机IP地址-有时也包括端口号" class="headerlink" title="②存有该资源的主机IP地址(有时也包括端口号)"></a>②存有该资源的主机IP地址(有时也包括端口号)</h3><h3 id="③主机资源的具体地址。如目录和文件名等"><a href="#③主机资源的具体地址。如目录和文件名等" class="headerlink" title="③主机资源的具体地址。如目录和文件名等"></a>③主机资源的具体地址。如目录和文件名等</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://xucanxx.github.io/2022/12/06/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-http%E7%9A%84URI%E5%92%8CURL/" data-id="cm8758vo9004c657k6zm45p46" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0/" rel="tag">果子私房笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-果子私房笔记-http的作用和RPC" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/12/06/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-http%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8CRPC/" class="article-date">
  <time datetime="2022-12-06T03:38:03.000Z" itemprop="datePublished">2022-12-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/12/06/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-http%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8CRPC/">果子私房笔记-http的作用和RPC</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="http的作用和RPC"><a href="#http的作用和RPC" class="headerlink" title="http的作用和RPC"></a>http的作用和RPC</h1><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP是一个协议，超文本传输协议，它基于TCP&#x2F;IP来传输文本、图片、视频、音频等。<br>HTTP不提供数据包的传输功能，也就是数据包从浏览器到服务端再来回的传输和它没关系，这些是TCP&#x2F;IP负责。<br>传输信息需要一种格式，http规定了一种通信格式，让任何服务器和客户端之间都能顺利交流，减少交互成本。http协议的格式很像我们的信封，有个固定的格式。所以其本质上就是客户端和服务端约定好的一种通信格式。</p>
<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>rpc 是应用层由用户自己在制定的协议</p>
<h2 id="HTTP和RPC区别"><a href="#HTTP和RPC区别" class="headerlink" title="HTTP和RPC区别"></a>HTTP和RPC区别</h2><p>HTTP指的是通信协议。<br>而RPC则是远程调用协议，其对应的是本地调用。<br>RPC的通信可以使用用HTTP协议，也可以自定义协议，是不做约束的。</p>
<h2 id="那为什么要有RPC？"><a href="#那为什么要有RPC？" class="headerlink" title="那为什么要有RPC？"></a>那为什么要有RPC？</h2><p>为什么要用RPC，直接使用WebClient HTTP调用不行么。其实RPC调用是因为服务的拆分，或者本身公司内部的多个服务之间的通信。服务的拆分独立部署，那服务间的调用就必然需要网络通信，用WebClient调用当然可行，但是比较麻烦。我们想即使服务被拆分了但是使用起来还是和之前本地调用一样方便。所以就出现了RPC框架，来屏蔽这些底层调用细节，使得我们编码上还是和之前本地调用相差不多。并且HTTP协议比较的冗余，RPC都是内部调用所以不需要太考虑通用性，只要公司内部保持格式统一即可。所以可以做各种定制化的协议来使得通信更高效。所以公司内部服务的调用一般都用RPC，而HTTP的优势在于通用，大家都认可这个协议。所以三方平台提供的接口都是通过HTTP协议调用的。所以现在知道为什么我们调用第三方都是HTTP，公司内部用RPC了吧。上面这段话看起来仿佛HTTP和RPC是对等关系，不过相信大家看了之前的解析心里应该都有数。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xucanxx.github.io/2022/12/06/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-http%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8CRPC/" data-id="cm8758voa004g657kda5xhnmo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0/" rel="tag">果子私房笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-果子私房笔记-http的常用方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/12/06/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-http%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/" class="article-date">
  <time datetime="2022-12-06T03:32:26.000Z" itemprop="datePublished">2022-12-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/12/06/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-http%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/">果子私房笔记-http的常用方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="http的常用方法"><a href="#http的常用方法" class="headerlink" title="http的常用方法"></a>http的常用方法</h1><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><p>用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器。<br>只请求服务端的数据，但是没有改变数据。</p>
<h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><p>用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。<br>比如上传一篇博客用的post会改变服务器端的数据。</p>
<h2 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h2><p>传输文件，报文主体中包含文件内容，保存到对应URI位置。</p>
<h2 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h2><p>获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。</p>
<h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><p>删除文件，与PUT方法相反，删除对应URI位置的文件。</p>
<h2 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h2><p>查询相应URI支持的HTTP方法。</p>
<h1 id="get和post的区别https-www-cnblogs-com-logsharing-p-8448446-html"><a href="#get和post的区别https-www-cnblogs-com-logsharing-p-8448446-html" class="headerlink" title="get和post的区别https://www.cnblogs.com/logsharing/p/8448446.html"></a>get和post的区别<a target="_blank" rel="noopener" href="https://www.cnblogs.com/logsharing/p/8448446.html">https://www.cnblogs.com/logsharing/p/8448446.html</a></h1><p>GET在浏览器回退时是无害的，而POST会再次提交请求。<br>GET产生的URL地址可以被Bookmark，而POST不可以。<br>GET请求会被浏览器主动cache，而POST不会，除非手动设置。<br>GET请求只能进行url编码，而POST支持多种编码方式。<br>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。<br>GET请求在URL中传送的参数是有长度限制的，而POST么有。<br>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。<br>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。<br>GET参数通过URL传递，POST放在Request body中。<br>GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器&#x2F;服务器的限制，导致他们在应用过程中体现出一些不同。<br>GET产生一个TCP数据包；POST产生两个TCP数据包。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://xucanxx.github.io/2022/12/06/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0-http%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/" data-id="cm8758voa004j657k0yrz5opj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0/" rel="tag">果子私房笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Ruby/">Ruby</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/c/">c++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/go/">go</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kafka/">kafka</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/openresty/">openresty</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/shell/">shell</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/">架构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ACM/" rel="tag">ACM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/brpc/" rel="tag">brpc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bug/" rel="tag">bug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0/" rel="tag">果子私房笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9E%8E%E7%8E%A9/" rel="tag">瞎玩</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%80%83%E7%A0%94/" rel="tag">考研</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/ACM/" style="font-size: 18.33px;">ACM</a> <a href="/tags/brpc/" style="font-size: 10px;">brpc</a> <a href="/tags/bug/" style="font-size: 10px;">bug</a> <a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 15px;">基础</a> <a href="/tags/%E6%9E%9C%E5%AD%90%E7%A7%81%E6%88%BF%E7%AC%94%E8%AE%B0/" style="font-size: 20px;">果子私房笔记</a> <a href="/tags/%E6%A1%86%E6%9E%B6/" style="font-size: 10px;">框架</a> <a href="/tags/%E7%9E%8E%E7%8E%A9/" style="font-size: 10px;">瞎玩</a> <a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 16.67px;">笔记</a> <a href="/tags/%E8%80%83%E7%A0%94/" style="font-size: 10px;">考研</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 11.67px;">随笔</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 13.33px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">三月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">四月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">一月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">十二月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">九月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">七月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">三月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">十二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/03/13/Linux/">Linux要点</a>
          </li>
        
          <li>
            <a href="/2025/03/13/c++/">C++要点</a>
          </li>
        
          <li>
            <a href="/2025/03/13/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>
          </li>
        
          <li>
            <a href="/2025/03/13/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>
          </li>
        
          <li>
            <a href="/2025/03/13/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E6%88%96%E7%BB%84%E4%BB%B6/">开源框架或组件</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2025 xucanxx<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>